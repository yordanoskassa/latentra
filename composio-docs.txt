# Welcome to Composio

<Frame>
  <img src="file:73eb76f2-69f1-415e-b9af-d5dd484f664f" alt="Composio introduction image" />
</Frame>

Composio is the fastest way to enable your AI agents to take real-world actions—without dealing with individual API integrations, authentication flows, or complex tool formatting.

* **Access 3000+ tools** out of the box across popular apps like Slack, GitHub, Notion, and more. [Browse tools →](/toolkits/introduction)
* **Enforce strict access and data controls** with [fine-grained permissions](/docs/authenticating-tools) for each tool and user.
* **Trigger agents and workflows** using [external events](/docs/using-triggers) (e.g., new message in Slack, new issue in GitHub).
* **Customize tools** for your proprietary APIs or internal functions via [modifiers](/docs/modifying-tool-schemas).
* **Integrate seamlessly** with frameworks like OpenAI, Anthropic, LangChain, Vercel AI SDK, and more.
* **Enhance reliability** with [input/output processing hooks](/docs/modifying-tool-inputs) to clean or transform data on the fly.

No more writing dozens of integrations. Composio handles auth, tool normalization, and execution—so your agents can focus on reasoning, not plumbing.

**We even optimize tool calls automatically for better accuracy**

## Get started in minutes

Watch our step-by-step implementation tutorials:

<Tabs>
  <Tab title="Python">
    <div>
      <iframe src="https://www.youtube.com/embed/wkqlR8322F4" title="Composio Python Quickstart" frameBorder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowFullScreen />
    </div>
  </Tab>

  <Tab title="TypeScript">
    <div>
      <iframe src="https://www.youtube.com/embed/ZRGb4xGl-kc" title="Composio TypeScript Quickstart" frameBorder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowFullScreen />
    </div>
  </Tab>
</Tabs>


# Quickstart

> Add authenticated tool-calling to any LLM agent in three steps.

This guide walks you through **authenticated tool calling**—the foundation of how Composio connects your AI agents to real-world actions.

You'll learn how to:

1. **Discover and add tools** relevant to your use case (e.g., Slack, GitHub, Notion) to your AI agent
2. **Authenticate tools** securely on behalf of a specific user, with fine-grained access control
3. **Enable your LLM** (like OpenAI, Claude, or LangChain) to invoke these tools reliably using structured tool call formats

## Prerequisites

Before you begin, ensure you have:

1. **A Composio account** - [Sign up here](https://platform.composio.dev) if you haven't already
2. **Python 3.10+** or **Node.js 18+** installed on your system
3. **Your API key** - Get it from the [developer dashboard](https://platform.composio.dev?next_page=/settings) and set it as an environment variable:

```bash
export COMPOSIO_API_KEY=your_api_key
```

## Install the SDK

First, install the Composio SDK for your preferred language:

<CodeGroup>
  ```bash title="Python" for="python"
  pip install composio
  ```

  ```bash title="TypeScript" for="typescript"
  npm install @composio/core
  ```
</CodeGroup>

## Initialize the SDK

You’ll need to initialize the SDK with your Composio API key. This allows you to authenticate requests and access tools on behalf of your users.

<CodeGroup>
  ```python Python
  from composio import Composio

  composio = Composio(
    # api_key="your-api-key",
  )
  ```

  ```typescript TypeScript
  import { Composio } from '@composio/core';

  // Initialize the SDK
  const composio = new Composio({
    // apiKey: 'your-api-key',
  });
  ```
</CodeGroup>

## Authorize Tools & Run Them with an Agent

Composio supports multiple LLM providers. Here’s how to use Composio with some of the most popular ones:

<Tabs>
  <Tab title="OpenAI (Python)">
    Composio ships with support for OpenAI provider out of the box.

    ```python Python title="Python" maxLines=40 
    from composio import Composio
    from openai import OpenAI

    openai = OpenAI()
    composio = Composio()
    user_id = "user@email.com"

    # Initialize connection request
    connection_request = composio.toolkits.authorize(user_id=user_id, toolkit="gmail")
    print(f"🔗 Visit the URL to authorize:\n👉 {connection_request.redirect_url}")

    # wait for the connection to be active
    connection_request.wait_for_connection()

    # Fetch tools
    tools = composio.tools.get(user_id=user_id, toolkits=["GMAIL"])

    # Invoke agent
    completion = openai.chat.completions.create(
        model="gpt-4o",
        messages=[
            {
                "role": "user",
                "content": "say 'hi from the composio quickstart' to soham@composio.dev",
                # we'll ship you free merch if you do ;)
            },
        ],
        tools=tools,
    )

    # Handle Result from tool call
    result = composio.provider.handle_tool_calls(user_id=user_id, response=completion)
    print(result)

    ```
  </Tab>

  <Tab title="Anthropic (Typescript)">
    You may install the Anthropic provider as well!

    **Installation**

    ```bash
    npm install @composio/anthropic
    ```

    ```typescript TypeScript title="TypeScript" maxLines=40 
    import { Composio } from '@composio/core';
    import { AnthropicProvider } from '@composio/anthropic';
    import Anthropic from '@anthropic-ai/sdk';

    const anthropic = new Anthropic();
    const composio = new Composio({ provider: new AnthropicProvider() });
    const userId = 'user@example.com';

    const connection = await composio.toolkits.authorize(userId, 'LINEAR');
    console.log(`🔗 Visit the URL to authorize:\n👉 ${connection.redirectUrl}`);

    const tools = await composio.tools.get(userId, { toolkits: ['LINEAR'] });
    await connection.waitForConnection();

    const msg = await anthropic.messages.create({
      model: 'claude-3-7-sonnet-latest',
      tools: tools,
      messages: [
        {
          role: 'user',
          content: 'Get my linear projects',
        },
      ],
      max_tokens: 1024,
    });

    const result = await composio.provider.handleToolCalls(userId, msg);
    console.log('✅ Tool results:', result);

    ```
  </Tab>

  <Tab title="Vercel AI SDK (Typescript)">
    You may install the Vercel AI provider as well!

    **Installation**

    ```bash
    npm install @composio/vercel
    ```

    ```typescript TypeScript title="TypeScript" maxLines=40 
    import { Composio } from '@composio/core';
    import { generateText } from 'ai';
    import { anthropic } from '@ai-sdk/anthropic';
    import { VercelProvider } from '@composio/vercel';
    import { v4 as uuidv4 } from 'uuid';

    const userId = uuidv4(); // The user's ID.
    const composio = new Composio({
      apiKey: process.env.COMPOSIO_API_KEY,
      provider: new VercelProvider(),
    });

    const connection = await composio.toolkits.authorize(userId, 'gmail');
    console.log(`🔗 Visit the URL to authorize:\n👉 ${connection.redirectUrl}`);

    await connection.waitForConnection();

    const tools = await composio.tools.get(userId, { tools: ['GMAIL_SEND_EMAIL'] });

    const { text } = await generateText({
      model: anthropic('claude-3-7-sonnet-20250219'),
      prompt: "say 'hi from the composio quickstart' to soham.g@composio.dev", // we'll ship you free merch if you do ;)
      tools,
    });

    console.log(text);

    ```
  </Tab>

  <Tab title="OpenAI Agents (Python)">
    You may install the OpenAI Agents provider as well!

    **Installation**

    ```bash
    pip install composio_openai_agents==0.8.0
    ```

    ```python Python title="Python" maxLines=40 
    import asyncio

    from agents import Agent, Runner

    from composio import Composio
    from composio_openai_agents import OpenAIAgentsProvider

    # Initialize Composio toolset
    user_id = "user@email.com"
    composio = Composio(provider=OpenAIAgentsProvider(), api_key="your-composio-api-key")

    # Initialize connection request
    connection_request = composio.toolkits.authorize(user_id=user_id, toolkit="github")
    print(f"🔗 Visit the URL to authorize:\n👉 {connection_request.redirect_url}")

    # wait for the connection to be active
    connection_request.wait_for_connection()

    # Get all the tools
    tools = composio.tools.get(
        user_id=user_id,
        tools=["GITHUB_STAR_A_REPOSITORY_FOR_THE_AUTHENTICATED_USER"],
    )

    # Create an agent with the tools
    agent = Agent(
        name="GitHub Agent",
        instructions="You are a helpful assistant that helps users with GitHub tasks.",
        tools=tools,
    )


    # Run the agent
    async def main():
        result = await Runner.run(
            starting_agent=agent,
            input=(
                "Star the repository composiohq/composio on GitHub. If done "
                "successfully, respond with 'Action executed successfully'"
            ),
        )
        print(result.final_output)


    asyncio.run(main())

    ```
  </Tab>
</Tabs>

<Note title="What just happened?">
  You just:

  1. Authorized a user account with Composio
  2. Passed those tool permissions into an LLM framework
  3. Let the LLM securely call real tools on the user’s behalf

  All OAuth flows and tool execution were automatically handled by Composio.
</Note>

## Next steps

<CardGroup cols={2}>
  <Card title="Use Providers" icon="fa-solid fa-plug" href="/providers/openai">
    Learn how to use Composio with various agent SDK and frameworks.
  </Card>

  <Card title="Work with tools" icon="fa-solid fa-toolbox" href="/docs/executing-tools">
    Learn how to work with tools and tool calling on a deeper level with Composio.
  </Card>

  <Card title="Manage authentication" icon="fa-solid fa-key" href="/docs/custom-auth-configs">
    Authorize tools for multiple users.
  </Card>

  <Card title="Triggers" icon="fa-solid fa-bolt" href="/docs/using-triggers">
    Listen for external events to trigger actions in your agents
  </Card>
</CardGroup>


# IDE and Agent Setup

> Setup your AI IDE and agent to help you ship faster with Composio

This comprehensive guide explains how to set up your IDE and coding agents to help you ship faster with Composio. We'll cover optimal configurations for popular editors and AI coding assistants.

## Cursor

Cursor is an AI-powered code editor that can significantly accelerate your development with Composio. Here's how to set it up optimally.

### Index Documentation

Cursor can index documentation, making it easy to ask questions about Composio and get contextual answers while coding.

<Frame>
  <img src="file:52fa377d-21c0-4b46-bccb-6b040b2ddc96" alt="Index docs" />
</Frame>

### To index Composio documentation:

1. Open Cursor Settings (Shift + Cmd/Ctrl + J)
2. Navigate to "Features" → "Codebase indexing"
3. Add the Composio documentation URLs:

* [https://docs.composio.dev](https://docs.composio.dev)
* [https://github.com/ComposioHQ/composio](https://github.com/ComposioHQ/composio) (for source code reference)

Once indexed, you can ask questions directly in the chat!

<Frame>
  <img src="file:a3e6a2f0-42da-461c-b3e9-69da345e509a" alt="Index docs question" />
</Frame>

### Optimize Cursor with Custom Rules

To get the best experience building with Composio, add custom instructions to Cursor's AI system. This helps the AI understand Composio's patterns and best practices.

<Frame>
  <img src="file:191168fd-8b4d-4161-94ec-e6c3ecfa5279" alt="Cursor settings" />
</Frame>

**To add custom rules:**

1. Open Cursor Settings (Shift + Cmd/Ctrl + J)
2. Go to "General" → "Rules for AI"
3. Add the appropriate prompt below based on your language

```md
Below is a list of Composio documentation. Use your web and fetch capabilities to read the documentation you need.
[Composio Documentation](https://docs.composio.dev)

- [Quickstart](https://docs.composio.dev/docs/quickstart.mdx): Add authenticated tool-calling to any LLM agent in three steps.
- [Configuration](https://docs.composio.dev/docs/configuration.mdx)
- [Providers](https://docs.composio.dev/docs/providers.mdx)
- [Executing Tools](https://docs.composio.dev/docs/executing-tools.mdx): Learn how to execute Composio's tools with different providers and frameworks
- [Authenticating Tools](https://docs.composio.dev/docs/authenticating-tools.mdx): Learn how to authenticate tools
- [Fetching and Filtering Tools](https://docs.composio.dev/docs/fetching-tools.mdx): Learn how to fetch and filter Composio's tools and toolkits
- [Modifying tool schemas](https://docs.composio.dev/docs/modifying-tool-schemas): Learn how to use schema modifiers to transform tool schemas before they are seen by agents.
- [Modifying tool inputs](https://docs.composio.dev/docs/modifying-tool-inputs): Learn how to use before execution modifiers to modify tool arguments before execution.
- [Modifying tool outputs](https://docs.composio.dev/docs/modifying-tool-outputs): Learn how to use after execution modifiers to transform tool results after execution.
- [Creating custom tools](https://docs.composio.dev/docs/custom-tools.mdx): Learn how to extend Composio's toolkits with your own tools
- [Custom Auth Configs](https://docs.composio.dev/docs/custom-auth-configs.mdx): Guide to using customizing auth configs for a toolkit
- [Programmatic Auth Configs](https://docs.composio.dev/docs/programmatic-auth-configs.mdx): Guide to creating auth configs programmatically
- [Custom Auth Parameters](https://docs.composio.dev/docs/custom-auth-params.mdx): Guide to injecting custom credentials in headers or parameters for a toolkit
- [Using Triggers](https://docs.composio.dev/docs/using-triggers.mdx): Send payloads to your system based on external events
- [OpenAI Providers](https://docs.composio.dev/providers/openai.mdx)
- [Anthropic Provider](https://docs.composio.dev/providers/anthropic.mdx)
- [LangGraph Provider](https://docs.composio.dev/providers/langgraph.mdx)
- [CrewAI Provider](https://docs.composio.dev/providers/crewai.mdx)
- [Vercel AI SDK Provider](https://docs.composio.dev/providers/vercel.mdx)
- [Google ADK Provider](https://docs.composio.dev/providers/google-adk.mdx)
- [OpenAI Agents Provider](https://docs.composio.dev/providers/openai-agents.mdx)
- [Mastra Provider](https://docs.composio.dev/providers/mastra.mdx)
- [Custom Providers](https://docs.composio.dev/toolsets/custom.mdx)

```


# Providers

Providers in Composio act as bridges between your AI models and external tools. They transform Composio's tools into formats that different AI frameworks can understand and use, making it possible to integrate with any AI framework seamlessly.

## What are Providers?

Think of providers as translators. Different AI frameworks (like OpenAI, Anthropic Claude, or LangChain) expect tools to be formatted in their specific way. Instead of manually converting Composio tools for each framework, providers handle this transformation automatically.

For example:

* OpenAI expects tools in a specific JSON schema format with type: "function"
* Anthropic Claude expects tools with an input\_schema structure
* LangChain expects tools as callable functions with specific parameters

Providers ensure that Composio tools work correctly with your chosen AI platform without you having to worry about the technical details.

## Using Providers

Here's how you can generate text with various providers using Composio SDK:

### Default Provider (OpenAI)

If you don't specify a provider, Composio uses the OpenAI provider by default:

<CodeGroup>
  ```python Python
  from openai import OpenAI
  from composio import Composio

  # Initialize tools.
  openai_client = OpenAI()
  composio = Composio(api_key="your-composio-api-key")

  # Define task.
  task = "Star a repo composiohq/composio on GitHub"

  # Get GitHub tools that are pre-configured
  tools = composio.tools.get(user_id="default", toolkits=["GITHUB"])

  # Get response from the LLM
  response = openai_client.chat.completions.create(
      model="gpt-4o-mini",
      tools=tools,
      messages=[
          {"role": "system", "content": "You are a helpful assistant."},
          {"role": "user", "content": task},
      ],
  )
  print(response)

  # Execute the function calls.
  result = composio.provider.handle_tool_calls(response=response, user_id="default")
  print(result)


  ```

  ```typescript TypeScript
  import { Composio } from '@composio/core';

  // Uses OpenAI provider automatically
  const composio = new Composio({
    apiKey: 'your-composio-api-key'
  });

  // Get tools formatted for OpenAI
  const tools = await composio.tools.get('default', {
    toolkits: ['github']
  });

  // Use with OpenAI
  const completion = await openai.chat.completions.create({
    model: 'gpt-4',
    messages: [
      { role: 'system', content: 'You are a helpful assistant.' },
      { role: 'user', content: 'Star the repo composiohq/composio on GitHub' },
    ],
    tools: tools // Already formatted for OpenAI
  });

  // Execute the function calls.
  const result = await composio.provider.handleToolCalls("user@example.com", completion)
  console.log(result)

  ```
</CodeGroup>

### Using a Different Provider

Different providers may require additional packages:

<CodeGroup>
  ```shell Python
  # Core SDK (includes OpenAI provider)
  pip install composio==0.8.0

  # Additional providers
  pip install composio_anthropic==0.8.0
  pip install composio_google==0.8.0
  pip install composio_langchain==0.8.0
  pip install composio_crewai==0.8.0
  ```

  ```shell Typescript
  # Core SDK (includes OpenAI provider)
  npm install @composio/core

  # Additional providers
  npm install @composio/anthropic
  npm install @composio/google  
  npm install @composio/langchain
  npm install @composio/vercel
  ```
</CodeGroup>

To use a different provider, specify it when initializing Composio:

<Tabs>
  <Tab title="OpenAI (Default)">
    OpenAI is a completion provider. You can use it to generate text, function calls.

    <CodeGroup>
      ```python Python
      from composio import Composio
      from composio_openai import OpenAIProvider

      composio = Composio(provider=OpenAIProvider())
      ```

      ```typescript TypeScript
      import { Composio } from "@composio/core";
      import { OpenAIProvider } from "@composio/openai";

      const composio = new Composio({ provider: new OpenAIProvider() });

      ```
    </CodeGroup>
  </Tab>

  <Tab title="Anthropic">
    Anthropic is a completion provider. You can use it to generate text, function calls.

    <CodeGroup>
      ```python Python
      from composio import Composio
      from composio_anthropic import AnthropicProvider

      composio = Composio(provider=AnthropicProvider())
      ```

      ```typescript TypeScript
      import { Composio } from "@composio/core";
      import { AnthropicProvider } from "@composio/anthropic";
      import { Anthropic } from "@anthropic-ai/sdk";

      const composio = new Composio({ provider: new AnthropicProvider() });

      ```
    </CodeGroup>
  </Tab>

  <Tab title="Vercel AI SDK">
    ```typescript TypeScript
    import { Composio } from "@composio/core";
    import { VercelProvider } from "@composio/vercel";

    const composio = new Composio({
      apiKey: process.env.COMPOSIO_API_KEY,
      provider: new VercelProvider(),
    });

    ```
  </Tab>

  <Tab title="Mastra">
    ```typescript TypeScript
    import { MastraProvider } from '@composio/mastra';
    import { Agent } from '@mastra/core/agent';
    import { Composio } from '@composio/core';

    const composio = new Composio({
      apiKey: process.env.COMPOSIO_API_KEY,
      provider: new MastraProvider(),
    });

    ```
  </Tab>

  <Tab title="OpenAI Agents">
    ```python Python
    import asyncio

    from agents import Agent, Runner

    from composio import Composio
    from composio_openai_agents import OpenAIAgentsProvider

    # Initialize Composio toolset
    composio = Composio(provider=OpenAIAgentsProvider())
    ```
  </Tab>
</Tabs>

## Supported Providers

Composio supports two different types of providers based on the type of AI framework you are using:

### Non-Agentic Providers

These providers work with AI platforms that use chat completion APIs, where you control the tool execution flow. The AI model analyzes your conversation and suggests which tools to use, but your code decides when and how to execute them.
With chat completion APIs, the typical flow is:

1. You send a message to the AI model along with available tools
2. The AI responds with either a text message or a request to use specific tools
3. If tools are requested, you execute them and send the results back to continue the conversation

<CardGroup cols={3}>
  <Card title="OpenAI Provider" icon={<img src="file:1a8e94c0-ac13-408c-9870-fe1beb15c561" width="24" height="24" />} href="/providers/openai">
    Integrate with OpenAI's tool calling and agents.
  </Card>

  <Card title="Anthropic Provider" icon={<img src="file:c6c1022a-658e-4551-8434-54c6dff3ec40" width="24" height="24" />} href="/providers/anthropic">
    Use Anthropic's Claude models with Composio tools.
  </Card>

  <Card title="Gemini Provider" icon={<img src="file:c8c46249-99f0-49a2-a728-478ff8dbc532" width="24" height="24" />} href="/providers/google">
    Integrate with Google's Gemini models.
  </Card>
</CardGroup>

### Agentic Providers

These providers work with AI frameworks that can execute tools autonomously. The AI agent can decide to run tools on its own without your direct intervention.

<CardGroup cols={3}>
  <Card title="LangChain Provider" icon={<img src="file:f164433c-57ea-4bb6-b7f3-1ca7a05c83da"/>} href="/providers/langchain">
    Add tools to LangChain agent flows.
  </Card>

  <Card title="CrewAI Provider" icon="fa-solid fa-people-group" href="/providers/crewai">
    Enable tool calling in CrewAI multi-agent systems.
  </Card>

  <Card title="Vercel AI SDK Provider" icon={<img src="file:1c920887-5362-45ce-b716-2b77034e9fb2" width="24" height="24" />} href="/providers/vercel">
    Use Composio tools with Vercel's AI SDK.
  </Card>

  <Card title="OpenAI Agents Provider" icon="fa-solid fa-user-astronaut" href="/providers/openai-agents">
    Add tools to OpenAI's new Agents API.
  </Card>

  <Card title="Mastra Provider" icon="fa-solid fa-cubes" href="/providers/mastra">
    Use Composio tools with Mastra agent framework.
  </Card>
</CardGroup>

<Tip title="Custom Providers" icon="puzzle">
  Using a framework not yet supported by Composio? Create a custom provider in [TypeScript](/providers/custom/typescript) or [Python](/providers/custom/python)!
</Tip>


# Authenticating Tools

> Create auth configs and connect user accounts

The first step in authenticating your Users is to create an **Auth Config**. Every toolkit has its own *authentication method* such as **OAuth**, **API key**, **Basic Auth**, or custom schemes.

An **Auth Config** is a *blueprint* that defines how authentication works for a toolkit across all your users. It defines:

1. **Authentication method** - *OAuth2*, *Bearer token*, *API key*, or *Basic Auth*
2. **Scopes** - *what actions your tools can perform*
3. **Credentials** - *whether you'll use your own app credentials or Composio's managed auth*

<Frame>
  <img src="file:c92f7b73-224f-4780-acb5-d89f79c04ea8" alt="Composio introduction image" />
</Frame>

## Creating an auth config

### Using the Dashboard

<Steps>
  <Step title="**Selecting a toolkit**">
    Navigate to <a target="_blank" href="https://platform.composio.dev?next_page=%2Fauth-configs" target="_blank">Auth Configs</a> tab in your dashboard and click "**Create Auth Config**". Find and select the toolkit you want to integrate (e.g., **Gmail**, **Slack**, **GitHub**).
  </Step>

  <Step title="**Selecting the Authentication method**">
    Each toolkit supports different authentication methods such as **OAuth**, **API Key**, **Bearer
    Token**. Select from the available options for your toolkit.
  </Step>

  <Step title="**Configure scopes**">
    Depending on your authentication method, you may need to configure scopes:

    * **OAuth2**: Configure scopes for what data and actions your integration can access.
    * **API Key/Bearer Token**: Permissions are typically fixed based on the key's access level.
  </Step>

  <Step title="**Authentication Management**">
    **For OAuth toolkits:**

    * **Development/Testing**: Use Composio's managed authentication (no setup required)
    * **Production**: Generate your own OAuth credentials from the toolkit's developer portal

    **For custom authentication schemes:**

    You must provide your own credentials regardless of environment.
  </Step>

  <Step title="**You are all set!**">
    Click "**Create Auth Configuration**" button and you have completed your first step! Now you can
    move ahead to authenticating your users by [Connecting an Account](#connecting-an-account).
  </Step>
</Steps>

<Note title="Auth configs are reusable">
  Auth configs contain your developer credentials and app-level settings (*scopes*, *authentication
  method*, etc.). Once created, you can reuse the same auth config for all your users.
</Note>

### When to create multiple auth configs?

You should create multiple auth configs for the same toolkit when you need:

* **Different authentication methods** - One OAuth config and one API key config
* **Different scopes** - Separate configs for read-only vs full access
* **Different OAuth apps** - Using separate client credentials for different environments
* **Different permission levels** - Limiting actions for specific use cases

<Card title="Programmatic creation" href="/docs/programmatic-auth-configs" icon="fa-solid fa-code">
  For managing auth configs across multiple projects, you can create them programmatically via the
  API
</Card>

## Connecting an account

With an auth config created, you're ready to authenticate your users!

You can either use [**Connect Link**](#hosted-authentication-connect-link) for a hosted authentication flow, or use [**Direct SDK Integration**](#direct-sdk-integration).

<Note>
  User authentication requires a User ID - a unique identifier that groups connected accounts together. Learn more about [User Management](/docs/user-management) to understand how to structure User IDs for your application.
</Note>

**Choose the section below that matches your toolkit's authentication method:**

### Hosted Authentication (Connect Link)

Redirect users to a Composio-hosted URL that handles the entire authentication process—OAuth flows, API key collection, or custom fields like subdomain. You can specify a callback URL to control where users return after authentication.

<CodeGroup>
  ```python Python {11-13}
  from composio import Composio

  composio = Composio(api_key="your_api_key")

  # Use the "AUTH CONFIG ID" from your dashboard
  auth_config_id = "your_auth_config_id"

  # Use a unique identifier for each user in your application
  user_id = 'user-1349-129-12'

  connection_request = composio.connected_accounts.link(user_id, auth_config_id, callback_url: 'https://your-app.com/callback')

  redirect_url = connection_request.redirect_url
  print(f"Visit: {redirect_url} to authenticate your account")
              
  # Wait for the connection to be established
  connected_account = connection_request.wait_for_connection()
  print(connected_account.id)
  ```

  ```typescript Typescript {11-13}
  import { Composio } from '@composio/core';

  const composio = new Composio({apiKey: "your_api_key"});

  // Use the "AUTH CONFIG ID" from your dashboard
  const authConfigId = 'your_auth_config_id';

  // Use a unique identifier for each user in your application
  const userId = 'user-1349-129-12';

  const connectionRequest = await composio.connectedAccounts.link(userId, authConfigId, {
    callbackUrl: 'https://your-app.com/callback'
  });
  const redirectUrl = connectionRequest.redirectUrl;
  console.log(`Visit: ${redirectUrl} to authenticate your account`);

  // Wait for the connection to be established
  const connectedAccount = await composio.connectedAccounts.waitForConnection(connectionRequest.id);
  console.log(connectedAccount.id)

  ```
</CodeGroup>

#### Customizing Connect Link

By default, users will see a Composio-branded authentication experience when connecting their accounts. To customize this interface with your application's branding:

1. Navigate to your Project Settings and select [Auth Screen](https://platform.composio.dev?next_page=/settings/auth-screen)
2. Configure your **Logo** and **App Title**

These settings will apply to all authentication flows using Connect Link, providing a white-labeled experience that maintains your brand identity throughout the authentication process.

### Direct SDK Integration

**Choose the section below that matches your toolkit's authentication method:**

#### OAuth Connections

For OAuth flows, you'll redirect users to complete authorization. You can specify a callback URL to control
where users return after authentication:

<CodeGroup>
  ```python Python {11-16}
  from composio import Composio

  composio = Composio(api_key="YOUR_COMPOSIO_API_KEY")

  # Use the "AUTH CONFIG ID" from your dashboard
  auth_config_id = "your_auth_config_id"

  # Use a unique identifier for each user in your application
  user_id = "user-1349-129-12"

  connection_request = composio.connected_accounts.initiate(
    user_id=user_id,
    auth_config_id=auth_config_id,
    config={"auth_scheme": "OAUTH2"},
    callback_url="https://www.yourapp.com/callback"
  )
  print(f"Redirect URL: {connection_request.redirect_url}")

  connected_account = connection_request.wait_for_connection()

  # Alternative: if you only have the connection request ID
  # connected_account = composio.connected_accounts.wait_for_connection(
  #  connection_request.id)
  # Recommended when the connection_request object is no longer available

  print(f"Connection established: {connected_account.id}")

  ```

  ```typescript {10-16}
  import { Composio } from '@composio/core';

  const composio = new Composio({apiKey: "YOUR_COMPOSIO_API_KEY"});

  // Use the "AUTH CONFIG ID" from your dashboard
  const authConfigId = 'your_auth_config_id';
  // Use a unique identifier for each user in your application
  const userId = 'user_4567';

  const connRequest = await composio.connectedAccounts.initiate(
    userId,
    authConfigId,
    {
      callbackUrl: 'https://www.yourapp.com/callback',
    }
  );
  console.log(`Redirect URL: ${connRequest.redirectUrl}`);

  const connectedAccount = await connRequest.waitForConnection();

  // Alternative: if you only have the connection request ID
  // const connectedAccount = await composio.connectedAccounts
  //   .waitForConnection(connRequest.id);
  // Recommended when the connRequest object is no longer available

  console.log(`Connection established: ${connectedAccount.id}`);
  ```
</CodeGroup>

#### Services with Additional Parameters

Some services like Zendesk require additional parameters such as `subdomain`:

<CodeGroup>
  ```python
  # For Zendesk - include subdomain
  connection_request = composio.connected_accounts.initiate(
    user_id=user_id,
    auth_config_id=auth_config_id,
    config=auth_scheme.oauth2(subdomain="mycompany")  # For mycompany.zendesk.com
  )
  ```

  ```typescript
  import { AuthScheme } from '@composio/core';
  // For Zendesk - include subdomain
  const connRequest = await composio.connectedAccounts.initiate(userId, authConfigId, {
    config: AuthScheme.OAuth2({
      subdomain: 'mycompany',
    }),
  });
  ```
</CodeGroup>

#### API Key Connections

For API key authentication, you can either *collect API keys from each user* or *use your own API key* for all users. Popular Toolkits that use API Keys include Stripe, Perplexity etc.

Here is how to initiate the flow:

<CodeGroup>
  ```python {16-22}
  from composio import Composio

  composio = Composio(api_key="your_api_key")

  # Use the "AUTH CONFIG ID" from your dashboard
  auth_config_id = "your_auth_config_id"

  # Use a unique identifier for each user in your application
  user_id = "user_12323"

  # API key provided by the user (collected from your app's UI)
  # or use your own key
  user_api_key = "user_api_key_here"

  connection_request = composio.connected_accounts.initiate(
    user_id=user_id,
    auth_config_id=auth_config_id,
    config={
      "auth_scheme": "API_KEY", "val": {"api_key": user_api_key}
    }
  )

  print(f"Connection established: {connection_request.id}")

  ```

  ```typescript {12-16}
  import { Composio, AuthScheme } from '@composio/core';

  const composio = new Composio({ apiKey: 'your_api_key' });

  // Use the "AUTH CONFIG ID" from your dashboard
  const authConfigId = 'your_auth_config_id';
  // Use a unique identifier for each user in your application
  const userId = 'user12345678';
  // API key provided by the user (collected from your app's UI)
  const userApiKey = 'user_api_key_here';

  const connectionRequest = await composio.connectedAccounts.initiate(userId, authConfigId, {
    config: AuthScheme.APIKey({
      api_key: userApiKey,
    }),
  });

  console.log(`Connection established: ${connectionRequest.id}`);
  ```
</CodeGroup>

## Fetching the required `config` parameters for an Auth Config

When working with any toolkits, you can **inspect an auth config** to understand its *authentication requirements* and *expected parameters*.

Here is how you would fetch the authentication method and input fields:

<CodeGroup>
  ```python {9}
  from composio import Composio

  composio = Composio(api_key="your_api_key")

  # Use the "AUTH CONFIG ID" from your dashboard
  auth_config_id = "your_auth_config_id"

  # Fetch the auth configuration details
  auth_config = composio.auth_configs.get(auth_config_id)

  # Check what authentication method this config uses
  print(f"Authentication method: {auth_config.auth_scheme}")

  # See what input fields are required
  print(f"Required fields: {auth_config.expected_input_fields}")

  ```

  ```typescript {9}
  import { Composio } from '@composio/core';

  const composio = new Composio({ apiKey: 'your_api_key' });

  // Use the "AUTH CONFIG ID" from your dashboard
  const authConfigId = 'your_auth_config_id';

  // Fetch the auth configuration details
  const authConfig = await composio.authConfigs.get(authConfigId);

  console.log(`Authentication method: ${authConfig.authScheme}`);
  console.log(`Required fields:`, authConfig.expectedInputFields);
  ```
</CodeGroup>

## Other Authentication Methods

Composio also supports a wide range of other auth schemas:

**Bearer Token** - Similar to API keys, provide the user's bearer token directly when creating the connection.

**Basic Auth** - Provide username and password credentials for services that use HTTP Basic Authentication.

**Custom Schemes** - Some toolkits use their own custom authentication methods. Follow the toolkit-specific requirements for such cases.

<Note title="Fetching auth config">
  For any of these methods, [fetch the config
  parameter](#fetching-the-required-config-parameters-for-an-auth-config) to determine the exact
  fields required. Every toolkit has its own requirements, and understanding these is essential for
  successfully creating connections.
</Note>

## Next Step

With authentication set up, you can now fetch and execute tools. See [Executing Tools](/docs/executing-tools) to get started.


# Fetching and Filtering Tools

> Learn how to fetch and filter Composio's tools and toolsets

To effectively use tools, it is recommended to fetch, inspect, and filter them based on your criteria.

This process returns a union of all tools that match the specified criteria, ensuring you provide the most relevant tools to the agents.

When fetching tools, they are automatically formatted to match the requirements of the provider you are using. This means you do not need to manually convert or adapt the tool format.

## Filtering by toolkit

Toolkits are collections of tools from a specific app!

Fetching tools from a toolkit is a good way to get a sense of the tools available.

<Tip title="Tools are ordered by importance" icon="info">
  When you fetch tools from a toolkit, the most important tools are returned first.

  Composio determines the importance of a tool based on the usage and relevance of the tool.
</Tip>

<CodeGroup>
  ```python Python maxLines=60 wordWrap
  tools = composio.tools.get(
      user_id,
      toolkits=["GITHUB", "HACKERNEWS"],
  )
  ```

  ```typescript TypeScript maxLines=60 wordWrap
  const tools = await composio.tools.get(
    userId,
    {
      toolkits: ["GITHUB", "LINEAR"],
    }
  );
  ```
</CodeGroup>

**Limiting the results**

Multiple toolkits have 100s of tools. These can easily overwhelm the LLM. Hence, the SDK allows you to limit the number of tools returned.

The default `limit` is 20 -- meaning you get the top 20 important tools from the toolkit.

<CodeGroup>
  ```python Python maxLines=60 wordWrap
  tools = composio.tools.get(
      user_id,
      toolkits=["GITHUB"],
      limit=5,  # Returns the top 5 important tools from the toolkit
  )
  ```

  ```typescript TypeScript maxLines=60 wordWrap
  const tools = await composio.tools.get(userId, {
    toolkits: ["GITHUB"],
    limit: 5, // Returns the top 5 important tools from the toolkit
  });
  ```
</CodeGroup>

**Filtering by scopes**

When working with OAuth-based toolkits, you can filter tools based on their required scopes. This is useful when you want to:

* Get tools that match specific permission levels
* Ensure tools align with available user permissions
* Filter tools based on their required OAuth scopes

<Tip title="Single Toolkit Requirement" icon="warning">
  Scope filtering can only be used with a single toolkit at a time.
</Tip>

<CodeGroup>
  ```python Python maxLines=60 wordWrap
  # Get GitHub tools that require specific scopes
  tools = composio.tools.get(
      user_id,
      toolkits=["GITHUB"],
      scopes=["repo"],  # Only get tools requiring these scopes
      limit=10
  )
  ```

  ```typescript TypeScript maxLines=60 wordWrap
  // Get GitHub tools that require specific scopes
  const tools = await composio.tools.get(userId, {
    toolkits: ["GITHUB"],
    scopes: ["repo"],  // Only get tools requiring these scopes
    limit: 10
  });
  ```
</CodeGroup>

## Filtering by tool

You may specify the list of tools to fetch by directly providing the tool names. Browse the list of tools [here](/tools) to view and inspect the tools for each toolkit.

<CodeGroup>
  ```python Python maxLines=60 wordWrap
  tools = composio.tools.get(
      user_id,
      tools=[
          "GITHUB_CREATE_AN_ISSUE",
          "GITHUB_CREATE_AN_ISSUE_COMMENT",
          "GITHUB_CREATE_A_COMMIT",
      ],
  )
  ```

  ```typescript TypeScript maxLines=60 wordWrap
  const tools = await composio.tools.get(userId, {
    tools: [
      "GITHUB_CREATE_AN_ISSUE",
      "GITHUB_CREATE_AN_ISSUE_COMMENT",
      "GITHUB_CREATE_A_COMMIT",
    ],
  });
  ```
</CodeGroup>

## Fetching raw tools

To examine the raw schema definition of a tool to understand the input/output parameters or to build custom logic around tool definitions, you can use the following methods. This can be useful for:

* Understanding exact input parameters and output structures.
* Building custom logic around tool definitions.
* Debugging tool interactions.
* Research and experimentation.

<CodeGroup>
  ```python Python title="Python" maxLines=40 
  tool = composio.tools.get_raw_composio_tool_by_slug("HACKERNEWS_GET_LATEST_POSTS")

  print(tool.model_dump_json())
  ```

  ```typescript TypeScript title="TypeScript" maxLines=40 
  const tool = await composio.tools.getRawComposioToolBySlug('GITHUB_GET_OCTOCAT');

  console.log(JSON.stringify(tool, null, 2));
  ```
</CodeGroup>

## Filtering by search (Experimental)

You may also filter tools by searching for them. This is a good way to find tools that are relevant to a given use case.

This step runs a semantic search on the tool names and descriptions and returns the most relevant tools.

<CodeGroup>
  ```python Python maxLines=60 wordWrap
  tools = composio.tools.get(
      user_id,
      search="hubspot organize contacts",
  )

  # Search within a specific toolkit
  tools = composio.tools.get(
      user_id,
      search="repository issues",
      toolkits=["GITHUB"],  # Optional: limit search to specific toolkit
      limit=5  # Optional: limit number of results
  )
  ```

  ```typescript TypeScript maxLines=60 wordWrap
  const tools = await composio.tools.get(userId, {
    search: "hubspot organize contacts",
  });

  // Search within a specific toolkit
  const tools = await composio.tools.get(userId, {
    search: "repository issues",
    toolkits: ["GITHUB"],  // Optional: limit search to specific toolkit
    limit: 5  // Optional: limit number of results
  });
  ```
</CodeGroup>

## Filter Combinations

When fetching tools, you must use one of these filter combinations:

1. **Tools Only**: Fetch specific tools by their slugs
   ```typescript
   { tools: ["TOOL_1", "TOOL_2"] }
   ```

2. **Toolkits Only**: Fetch tools from specific toolkits
   ```typescript
   { toolkits: ["TOOLKIT_1", "TOOLKIT_2"], limit?: number }
   ```

3. **Single Toolkit with Scopes**: Fetch tools requiring specific OAuth scopes
   ```typescript
   { toolkits: ["GITHUB"], scopes: ["read:repo"], limit?: number }
   ```

4. **Search**: Search across all tools or within specific toolkits
   ```typescript
   { search: "query", toolkits?: string[], limit?: number }
   ```

These combinations are mutually exclusive - you can't mix `tools` with `search` or use `scopes` with multiple toolkits.


# Executing Tools

> Learn how to execute Composio's tools with different providers and frameworks

LLMs on their own can only do generation. Tool calling changes that by letting them interact with external services. Instead of just drafting an email, the model can call `GMAIL_SEND_EMAIL` to actually send it. The tool's results feed back to the LLM, closing the loop so it can decide, *act,* observe, and adapt.

In Composio, every **tool** is a single API action—fully described with schema, parameters, and return type. Tools live inside **toolkits** like *Gmail, Slack, or GitHub*, and Composio handles authentication and user scoping.

<Tip icon="info">
  **User Scoping**: All tools are scoped to a specific user - that's why every example includes a
  `user_id`. Learn how to structure User IDs in [User Management](./user-management). Each user must authenticate with their respective services (Gmail, Calendar, etc.) - see [Authentication](./authenticating-tools)
</Tip>

## Using Chat Completions

Use the Composio SDK with providers like OpenAI, Anthropic, and Google AI. To learn how to set-up these providers, see [Providers](/providers/openai).

<CodeGroup>
  ```python Python {32-33} title="Python (OpenAI)" maxLines=40 
  from composio import Composio
  from composio_openai import OpenAIProvider
  from openai import OpenAI
  from datetime import datetime

  # Use a unique identifier for each user in your application
  user_id = "user-k7334" 

  # Create composio client
  composio = Composio(provider=OpenAIProvider(), api_key="your_composio_api_key")

  # Create openai client
  openai = OpenAI()

  # Get calendar tools for this user
  tools = composio.tools.get(
    user_id=user_id,
    tools=["GOOGLECALENDAR_EVENTS_LIST"]
  )

  # Ask the LLM to check calendar
  result = openai.chat.completions.create(
    model="gpt-4o-mini",
    tools=tools,
    messages=[
        {"role": "system", "content": "You are a helpful assistant."},
        {"role": "user", "content": f"What's on my calendar for the next 7 days. Its {datetime.now().strftime("%Y-%m-%d")} today.",}
    ]
  )


  # Handle tool calls
  result = composio.provider.handle_tool_calls(user_id=user_id, response=result)
  print(result)
  ```

  ```typescript TypeScript {37-38} title="TypeScript (Anthropic)" maxLines=40 
  import { Composio } from '@composio/core';
  import { AnthropicProvider } from '@composio/anthropic';
  import { Anthropic } from '@anthropic-ai/sdk';

  // Use a unique identifier for each user in your application
  const userId = 'user-k7334';

  // Create anthropic client
  const anthropic = new Anthropic();

  // Create Composio client
  const composio = new Composio({
  apiKey: "your-composio-api-key",
  provider: new AnthropicProvider(),
  });

  // Get calendar tools for this user
  const tools = await composio.tools.get(userId, {
  tools: ['GOOGLECALENDAR_EVENTS_LIST'],
  });

  const today = new Date();

  // Ask the LLM to check calendar
  const msg = await anthropic.messages.create({
  model: 'claude-sonnet-4-20250514',
  tools: tools,
  messages: [
    {
      role: 'user',
      content: `What's on my calendar for the next 7 days starting today:${today.toLocaleDateString()}?`,
    },
  ],
  max_tokens: 1024,
  });

  // Handle tool calls
  const result = await composio.provider.handleToolCalls(userId, msg);
  console.log('Results:', JSON.stringify(result, null, 2));

  ```
</CodeGroup>

## Using Agentic Frameworks

Agentic frameworks automatically handle the tool execution loop.
Composio provides support for frameworks like this by making sure the tools are formatted into the correct objects for the agentic framework to execute.

<CodeGroup>
  ```python Python {19-23} title="Python (OpenAI Agents SDK)" maxLines=40 
  import asyncio
  from agents import Agent, Runner
  from composio import Composio
  from composio_openai_agents import OpenAIAgentsProvider

  # Use a unique identifier for each user in your application
  user_id = "user-k7334"

  # Initialize Composio toolset
  composio = Composio(provider=OpenAIAgentsProvider(), api_key="your_composio_api_key")

  # Get all tools for the user
  tools = composio.tools.get(
    user_id=user_id,
    toolkits=["COMPOSIO_SEARCH"],
  )

  # Create an agent with the tools
  agent = Agent(
    name="Deep Researcher",
    instructions="You are an investigative journalist.",
    tools=tools,
  )

  async def main():
    result = await Runner.run(
        starting_agent=agent,
        input=("Do a thorough DEEP research on Golden Gate Bridge"),
    )
    print(result.final_output)

  # Run the agent
  asyncio.run(main())

  ```

  ```typescript TypeScript {22-31} title="TypeScript (Vercel AI SDK)" maxLines=40 
  import { Composio } from '@composio/core';
  import { generateText } from 'ai';
  import { anthropic } from '@ai-sdk/anthropic';
  import { VercelProvider } from '@composio/vercel';

  // Use a unique identifier for each user in your application
  const userId = 'user-k7334';

  // Initialize Composio toolset
  const composio = new Composio({
  apiKey: process.env.COMPOSIO_API_KEY,
  provider: new VercelProvider(),
  });

  // Get all tools for the user
  const tools = await composio.tools.get(userId, {
  toolkits: ['HACKERNEWS_GET_LATEST_POSTS'],
  limit: 10,
  });

  // Generate a deep research on hackernews
  const { text } = await generateText({
  model: anthropic('claude-sonnet-4-20250514'),
  messages: [
    {
      role: 'user',
      content: 'Do a thorough DEEP research on the top articles on Hacker News about Composio',
    },
  ],
  tools,
  });

  console.log(text);

  ```
</CodeGroup>

## Direct Tool execution

In case you just want to call a tool without using any framework or LLM provider, you can use the `execute` method directly.

<Tip icon="lightbulb">
  **Finding tool arguments**: In the [Auth Configs
  tab](https://platform.composio.dev?next_page=/auth-configs) → Select your toolkit → Tools &
  Triggers → Select the tool to see its required and optional parameters, types, and descriptions.
</Tip>

<CodeGroup>
  ```python Python title="Python" maxLines=40 
  from composio import Composio

  user_id = "user-k7334"
  composio = Composio(api_key="your_composio_key")

  # Find available arguments for any tool in the Composio dashboard
  result = composio.tools.execute(
    "GITHUB_LIST_STARGAZERS",
    user_id=user_id,
    arguments={"owner": "ComposioHQ", "repo": "composio", "page": 1, "per_page": 5}
  )
  print(result)
  ```

  ```typescript TypeScript title="TypeScript" maxLines=40 
  import { Composio } from "@composio/core";

  const userId = "user-k7334";
  const composio = new Composio({apiKey: "your_composio_key"});

  // Find available arguments for any tool in the Composio dashboard
  const result = await composio.tools.execute("GITHUB_LIST_STARGAZERS", {
  userId,
  arguments: {
    "owner": "ComposioHQ", 
    "repo": "composio", 
    "page": 1, 
    "per_page": 5
  },
  });
  console.log('GitHub stargazers:', JSON.stringify(result, null, 2));
  ```
</CodeGroup>

### Proxy Execute -- Manually calling toolkit APIs

You can proxy requests to any supported toolkit API and let Composio inject the **authentication state**. This is useful when you need an API endpoint that isn't available as a predefined tool.

The `endpoint` can be a relative path or absolute URL. Composio uses the `connected_account_id` to determine the toolkit and resolve relative paths against the appropriate base URL.

<CodeGroup>
  ```python Python {5} title="Python" maxLines=40 
  # Send a proxy request to the endpoint
  response = composio.tools.proxy(
    endpoint="/repos/composiohq/composio/issues/1",
    method="GET",
    connected_account_id="ca_jI6********",  # use connected account for github
    parameters=[
        {
            "name": "Accept",
            "value": "application/vnd.github.v3+json",
            "type": "header",
        },
    ],
  )

  print(response)

  ```

  ```typescript TypeScript {5} title="TypeScript" maxLines=40 
  // Send a proxy request to the endpoint
  const { data } = await composio.tools.proxyExecute({
    endpoint:'/repos/composiohq/composio/issues/1',
    method: 'GET',
    connectedAccountId: 'ca_jI*****', // use connected account for github
     parameters:[
        {
            "name": "Accept",
            "value": "application/vnd.github.v3+json",
            "in": "header",
        },
    ],
  });

  console.log(data);

  ```
</CodeGroup>

<Tip icon="info">
  Need an API that isn't supported by any Composio toolkit, or want to extend an existing one? Learn
  how to [create custom tools](/docs/custom-tools).
</Tip>

## Automatic File Handling

Composio handles file operations automatically. Pass file paths to tools that need them, and get local file paths back from tools that return files.

### File Upload

Pass local file paths, URLs, or File objects to tools that accept files:

<CodeGroup>
  ```python Python title="Python" maxLines=40 
  # Upload a local file to Google Drive
  result = composio.tools.execute(
    slug="GOOGLEDRIVE_UPLOAD_FILE",
    user_id="user-1235***",
    arguments={"file_to_upload": os.path.join(os.getcwd(), "document.pdf")},  # Local file path
  )

  print(result)  # Print Google Drive file details

  ```

  ```typescript TypeScript title="TypeScript" maxLines=40 
  // Upload a local file to Google Drive
  const result = await composio.tools.execute('GOOGLEDRIVE_UPLOAD_FILE', {
  userId: 'user-4235***',
  arguments: {
    file_to_upload: path.join(__dirname, 'document.pdf')  // Local file path
  }
  });

  console.log(result.data);  // Contains Google Drive file details

  ```
</CodeGroup>

### File Download

When tools return files, Composio downloads them to the local directory and provides file path in the response:
When tools return files, Composio downloads them to the local directory and provides the file path in the response:

<CodeGroup>
  ```python Python title="Python" maxLines=40 
  composio = Composio(
    api_key="your_composio_key", file_download_dir="./downloads"
  )  # Optional: Specify the directory to download files to

  result = composio.tools.execute(
    "GOOGLEDRIVE_DOWNLOAD_FILE",
    user_id="user-1235***",
    arguments={"file_id": "your_file_id"},
  )

  # Result includes local file path
  print(result)

  ```

  ```typescript TypeScript title="TypeScript" maxLines=40 
  // Download a file from Google Drive
  const result = await composio.tools.execute('GOOGLEDRIVE_DOWNLOAD_FILE', {
    userId: 'user-1235***',
    arguments: {
      file_id: 'your-file-id'
    }
  });

  // Result includes local file path
  console.log(result);
  ```
</CodeGroup>

### Disabling Auto File Handling

You can disable automatic file handling when initializing the TypeScript SDK. When disabled, handle file uploads and downloads manually using `files.upload` and `files.download`:

<CodeGroup>
  ```typescript TypeScript maxLines=60 wordWrap
  const composio = new Composio({
    apiKey: process.env.COMPOSIO_API_KEY,
    autoUploadDownloadFiles: false
  });

  // Now you need to handle files manually using composio.files API
  const fileData = await composio.files.upload({
  filePath: path.join(\_\_dirname, 'document.pdf'),
  toolSlug: 'GOOGLEDRIVE_UPLOAD_FILE',
  toolkitSlug: 'googledrive'
  });

  ```
</CodeGroup>

```
```


# Schema Modifiers

> Learn how to use schema modifiers to transform tool schemas before they are seen by agents.

Schema modifiers are part of Composio SDK's powerful middleware capabilities that allow you to customize and extend the behavior of tools.

## Schema Modifiers

Schema modifiers transform a tool's schema before the tool is seen by an agent.

<Frame>
  <img src="file:cd8de836-0f64-48ec-a51c-56356bfdddf5" alt="Schema Modifier" />
</Frame>

**Useful for:**

* Modifying or rewriting the tool description to better fit your use case.
* Adding arguments to the tool. For example, adding a `thought` argument to the tool to prompt the agent to explain the reasoning.
* Hiding arguments from the tool. In cases where the argument is irrelevant to the tool.
* Adding extra arguments to the tool schema for custom use cases or execution.
* Adding default values to tool arguments.

<Note>
  Below we modify the schema of the `HACKERNEWS_GET_LATEST_POSTS` to make the `size` argument
  required and remove the `page` argument.
</Note>

<CodeGroup>
  ```python Python maxLines=60  wordWrap
  from composio import Composio, schema_modifier
  from composio.types import Tool

  user_id = "your@email.com"

  @schema_modifier(tools=["HACKERNEWS_GET_LATEST_POSTS"])
  def modify_schema(
      tool: str,
      toolkit: str,
      schema: Tool,
  ) -> Tool:
      _ = schema.input_parameters["properties"].pop("page", None)
      schema.input_parameters["required"] = ["size"]
      return schema

  tools = composio.tools.get(
      user_id=user_id,
      tools=["HACKERNEWS_GET_LATEST_POSTS", "HACKERNEWS_GET_USER"],
      modifiers=[
          modify_schema,
      ]
  )
  ```

  ```typescript TypeScript maxLines=60 wordWrap
  const userId = "your@email.com";

  const tools = await composio.tools.get(
    userId,
    {
      tools: ["HACKERNEWS_GET_LATEST_POSTS", "HACKERNEWS_GET_USER"],
    },
    {
      modifySchema: ({ toolSlug, toolkitSlug, schema }) => {
        if (toolSlug === "HACKERNEWS_GET_LATEST_POSTS") {
          const { inputParameters } = schema;
          if (inputParameters?.properties) {
            delete inputParameters.properties["page"];
          }
          inputParameters.required = ["size"];
        }
        return schema;
      },
    }
  );

  console.log(JSON.stringify(tools, null, 2));

  ```
</CodeGroup>

In using the above modified tool schema, the `page` argument is removed and the `size` argument is required.

You can test this out by viewing the tool call response in the LLM too!

<Accordion title="Schema modified tool call">
  <CodeGroup>
    ```python Python maxLines=60 wordWrap

    from openai import OpenAI
    from composio import Composio, schema_modifier
    from composio.types import Tool
    from composio_openai import OpenAIProvider


    @schema_modifier(tools=["HACKERNEWS_GET_LATEST_POSTS"])
    def modify_schema(
        tool: str,
        toolkit: str,
        schema: Tool,
    ) -> Tool:
        _ = schema.input_parameters["properties"].pop("page", None)
        schema.input_parameters["required"] = ["size"]
        return schema

    # Initialize tools.
    openai_client = OpenAI()
    composio = Composio(provider=OpenAIProvider())

    # Define task.
    task = "Get the latest posts from Hacker News"

    # Get GitHub tools that are pre-configured
    tools = composio.tools.get(
      user_id="default",
      tools=['HACKERNEWS_GET_LATEST_POSTS', 'HACKERNEWS_GET_USER'],
      modifiers=[
          modify_schema,
      ],
    )

    # Get response from the LLM
    response = openai_client.chat.completions.create(
        model="gpt-4o-mini",
        tools=tools,
        messages=[
            {"role": "system", "content": "You are a helpful assistant."},
            {"role": "user", "content": task},
        ],
    )
    print(response)

    # Execute the function calls.
    result = composio.provider.handle_tool_calls(response=response, user_id="default")
    print(result)
    ```

    ```typescript TypeScript maxLines=60 wordWrap
    import { Composio } from '@composio/core';
    import { OpenAI } from 'openai';

    const composio = new Composio({
      apiKey: process.env.COMPOSIO_API_KEY,
    });
    const openai = new OpenAI();

    const userId = 'your@email.com';

    const tools = await composio.tools.get(
      userId,
      {
        tools: ['HACKERNEWS_GET_LATEST_POSTS', 'HACKERNEWS_GET_USER'],
      },
      {
        modifySchema: ({ toolSlug, toolkitSlug, schema }) => {
          if (toolSlug === 'HACKERNEWS_GET_LATEST_POSTS') {
            const { inputParameters } = schema;
            if (inputParameters?.properties) {
              delete inputParameters.properties['page'];
            }
            inputParameters.required = ['size'];
          }
          return schema;
        },
      }
    );

    console.log(JSON.stringify(tools, null, 2));

    const response = await openai.chat.completions.create({
      model: 'gpt-4o-mini',
      messages: [
        {
          role: 'system',
          content: 'You are a helpful assistant that can help with tasks.',
        },
        { role: 'user', content: 'Get the latest posts from Hacker News' },
      ],
      tools: tools,
      tool_choice: 'auto',
    });

    console.log(response.choices[0].message.tool_calls);
    ```
  </CodeGroup>
</Accordion>

## Example: Modifying the tool description

Sometimes you need to provide additional context to help the agent understand how to use a tool correctly. This example demonstrates modifying the description of the `GITHUB_LIST_REPOSITORY_ISSUES` tool to specify a default repository when none is provided.

<Note>
  This approach is particularly useful when you want to guide the agent's behavior without changing the tool's underlying functionality.
</Note>

In this example:

* We append additional instructions to the tool's description
* The modified description tells the agent to use `composiohq/composio` as the default repository
* This helps prevent errors when the agent forgets to specify a repository parameter

<CodeGroup>
  ```python Python {13-20} title="Python" maxLines=40 
  from composio import Composio, schema_modifier
  from composio.types import Tool
  from composio_google import GoogleProvider
  from google import genai
  from google.genai import types
  from uuid import uuid4

  composio = Composio(provider=GoogleProvider())
  client = genai.Client()
  user_id = uuid4()   # User ID from DB/App


  @schema_modifier(tools=["GITHUB_LIST_REPOSITORY_ISSUES"])
  def append_repository(
      tool: str, 
      toolkit: str,
      schema: Tool,
  ) -> Tool:
      schema.description += " When not specified, use the `composiohq/composio` repository"
      return schema


  tools = composio.tools.get(
      user_id=user_id, tools=["GITHUB_LIST_REPOSITORY_ISSUES"], modifiers=[append_repository]
  )

  print(tools)
  ```

  ```typescript TypeScript {13-18} title="TypeScript" maxLines=40 
  import { Composio } from '@composio/core';
  import { generateText } from 'ai';
  import { anthropic } from '@ai-sdk/anthropic';
  import { VercelProvider } from '@composio/vercel';
  import { v4 as uuidv4 } from 'uuid';

  const userId = uuidv4(); // The user's ID.
  const composio = new Composio({
    apiKey: process.env.COMPOSIO_API_KEY,
    provider: new VercelProvider(),
  });

  const addDescription = ({ toolSlug, toolkitSlug, schema }) => {
    if (toolSlug === 'GITHUB_LIST_REPOSITORY_ISSUES') {
      schema.description += 'If not specified, use the `composiohq/composio` repository';
    }
    return schema;
  };

  const tools = await composio.tools.get(
    userId,
    {
      tools: ['GITHUB_LIST_REPOSITORY_ISSUES'],
    },
    {
      modifySchema: addDescription,
    }
  );

  console.log(tools);

  ```
</CodeGroup>


# Before Execution Modifiers

> Learn how to use before execution modifiers to modify tool arguments before execution.

Before execution modifiers are part of Composio SDK's powerful middleware capabilities that allow you to customize and extend the behavior of tools.

## Before Execution Modifiers

These modifiers are called before the tool is executed by the LLM. This allows you to modify the *arguments* called by the LLM before they are executed by Composio.

**Useful for:**

* Injecting an argument into the tool execution.
* Overriding the arguments emitted by the LLM.

<Frame>
  <img src="file:f966c8ef-8895-4058-8eee-b571bb561f14" alt="Before Execution Modifier" />
</Frame>

<Note>
  Below we use the `beforeExecute` modifier to modify the number of posts returned by the
  `HACKERNEWS_GET_LATEST_POSTS` tool.
</Note>

<Tabs>
  <Tab title="With Chat Completions">
    Since completion providers don't have a function execution step -- Composio will execute the tool call directly.

    Hence, the modifier is configured on the `tools.execute` method.

    <CodeGroup>
      ```python Python maxLines=60  wordWrap
      from openai import OpenAI
      from composio import Composio, before_execute
      from composio.types import ToolExecuteParams

      composio = Composio()
      openai_client = OpenAI()
      user_id = "user@email.com"

      @before_execute(tools=["HACKERNEWS_GET_LATEST_POSTS"])
      def before_execute_modifier(
          tool: str,
          toolkit: str,
          params: ToolExecuteParams,
      ) -> ToolExecuteParams:
          params["arguments"]["size"] = 1
          return params


      # Get tools
      tools = composio.tools.get(user_id=user_id, slug="HACKERNEWS_GET_LATEST_POSTS")

      # Get response from the LLM
      response = openai_client.chat.completions.create(
          model="gpt-4o-mini",
          tools=tools,
          messages=[{"role": "user", "content": "Fetch latest posts from hackernews"}],
      )
      print(response)

      # Execute the function calls.
      result = composio.provider.handle_tool_calls(
          response=response,
          user_id="default",
          modifiers=[
              before_execute_modifier,
          ],
      )
      print(result)
      ```

      ```typescript TypeScript maxLines=60 wordWrap {11, 20-28}
      const response = await openai.chat.completions.create({
        model: "gpt-4o-mini",
        messages,
        tools,
        tool_choice: "auto",
      });

      const { tool_calls } = response.choices[0].message;
      console.log(tool_calls);

      if (tool_calls) {
        const {
          function: { arguments: toolArgs },
        } = tool_calls[0];

        const result = await composio.tools.execute(
          "HACKERNEWS_GET_LATEST_POSTS",
          {
            userId,
            arguments: JSON.parse(toolArgs),
          },
          {
            beforeExecute: ({ toolSlug, toolkitSlug, params }) => {
              if (toolSlug === "HACKERNEWS_GET_LATEST_POSTS") {
                params.arguments.size = 1;
              }
              console.log(params);
              return params;
            },
          }
        );
        console.log(JSON.stringify(result, null, 2));
      }

      ```
    </CodeGroup>
  </Tab>

  <Tab title="With Agentic Frameworks">
    Agentic providers have a function execution step.
    The modifier is configured on the `tools.get` method which modifies the execution logic within the framework!

    <CodeGroup>
      ```python Python (CrewAI) maxLines=60  wordWrap
      from composio import Composio, before_execute
      from composio.types import ToolExecuteParams
      from composio_crewai import CrewAIProvider

      composio = Composio(provider=CrewAIProvider())

      @before_execute(tools=["LINEAR_CREATE_LINEAR_ISSUE"])
      def modify_linear_project_id(
          tool: str,
          toolkit: str,
          params: ToolExecuteParams,
      ) -> ToolExecuteParams:
          params["arguments"]["project_id"] = "1234567890"
          return params

      tools = composio.tools.get(
          user_id="default",
          tools=[
              "HACKERNEWS_GET_LATEST_POSTS",
              "HACKERNEWS_GET_USER",
              "LINEAR_CREATE_LINEAR_ISSUE",
          ],
          modifiers=[
              modify_linear_project_id,
          ]
      )
      ```

      ```typescript TypeScript (Mastra) maxLines=60  wordWrap {22-26}
      import { Composio } from "@composio/core";
      import { MastraProvider } from "@composio/mastra";
      import { Agent } from "@mastra/core/agent";

      const composio = new Composio({
        apiKey: process.env.COMPOSIO_API_KEY,
        provider: new MastraProvider(),
      });

      const userId = "user@acme.com"; // The user's ID.

      const agenticTools = await composio.tools.get(
        userId,
        {
          tools: [
            "HACKERNEWS_GET_LATEST_POSTS",
            "HACKERNEWS_GET_USER",
            "LINEAR_CREATE_LINEAR_ISSUE",
          ],
        },
        {
          beforeExecute: ({toolSlug, toolkitSlug, params}) => {
            if (toolSlug === "LINEAR_CREATE_LINEAR_ISSUE") {
              params.arguments.project_id = "1234567890";
            }
            return params;
          },
        }
      );

      const { text } = await generateText({
        model: openai("gpt-4o-mini"),
        messages: [
          { role: "user", content: "Create an issue to `sid` to add RLS" },
        ],
        tools: agenticTools,
        maxSteps: 5,
      });

      ```
    </CodeGroup>
  </Tab>
</Tabs>


# After Execution Modifiers

> Learn how to use after execution modifiers to transform tool results after execution.

After execution modifiers are part of Composio SDK's powerful middleware capabilities that allow you to customize and extend the behavior of tools.

## After Execution Modifiers

These modifiers are called after the tool is executed by the LLM. This allows you to modify the *result* of the tool before it is returned to the agent.

**Useful for:**

* Modifying or truncating the output of the tool.
* Converting the output to a different format before returning it to the agent.

<Frame>
  <img src="file:2e6c6c7a-145f-4f0c-8644-c7026fc6d7ba" alt="After Execution Modifier" />
</Frame>

<Note>
  Below we use the `afterExecute` modifier to truncate the output of the `HACKERNEWS_GET_USER`
  tool and only return the karma of the user.
</Note>

<Tabs>
  <Tab title="With Chat Completions">
    Since completion providers don't have a function execution step -- Composio will execute the tool call directly.

    Hence, the modifier is configured on the `tools.execute` method.

    <CodeGroup>
      ```python Python maxLines=60  wordWrap
      from composio import Composio, after_execute
      from composio.types import ToolExecutionResponse

      @after_execute(tools=["HACKERNEWS_GET_USER"])
      def after_execute_modifier(
          tool: str,
          toolkit: str,
          response: ToolExecutionResponse,
      ) -> ToolExecutionResponse:
          return {
              **response,
              "data": {
                  "karma": response["data"]["karma"],
              },
          }

      tools = composio.tools.get(user_id=user_id, slug="HACKERNEWS_GET_USER")
      # Get response from the LLM
      response = openai_client.chat.completions.create(
          model="gpt-4o-mini",
          tools=tools,
          messages=messages,
      )
      print(response)

      # Execute the function calls.
      result = composio.provider.handle_tool_calls(
        response=response,
        user_id="default",
        modifiers=[
           after_execute_modifier, 
        ]
      )
      print(result)
      ```

      ```typescript TypeScript maxLines=60  wordWrap
      const response = await openai.chat.completions.create({
        model: "gpt-4o-mini",
        messages,
        tools,
        tool_choice: "auto",
      });

      const { tool_calls } = response.choices[0].message;
      console.log(tool_calls);

      if (tool_calls) {
        const {
          function: { arguments: toolArgs },
        } = tool_calls[0];

        const result = await composio.tools.execute(
          "HACKERNEWS_GET_USER",
          {
            userId,
            arguments: JSON.parse(toolArgs),
          },
          {
            afterExecute: ({ toolSlug, toolkitSlug, result }) => {
              if (toolSlug === "HACKERNEWS_GET_USER") {
                const { data } = result;
                const { karma } = data.response_data as { karma: number };
                return {
                  ...result,
                  data: { karma },
                };
              }
              return result;
            },
          }
        );
        console.log(JSON.stringify(result, null, 2));
      }

      ```
    </CodeGroup>
  </Tab>

  <Tab title="With Agentic Frameworks">
    Agentic providers have a function execution step.
    The modifier is configured on the `tools.get` method which modifies the execution logic within the framework!

    <CodeGroup>
      ```python Python (CrewAI) maxLines=60  wordWrap
      from composio import Composio, after_execute
      from composio.types import ToolExecutionResponse
      from composio_crewai import CrewAIProvider

      composio = Composio(provider=CrewAIProvider())

      @after_execute(tools=["HACKERNEWS_GET_USER"])
      def after_execute_modifier(
          tool: str,
          toolkit: str,
          response: ToolExecutionResponse,
      ) -> ToolExecutionResponse:
          return {
              **response,
              "data": {
                  "karma": response["data"]["karma"],
              },
          }


      tools = composio.tools.get(
          user_id="default",
          slug="HACKERNEWS_GET_USER",
          modifiers=[
              after_execute_modifier,
          ]
      )
      ```

      ```typescript TypeScript (Vercel) maxLines=60  wordWrap {24-27}
      import { Composio } from "@composio/core";
      import { VercelProvider } from "@composio/vercel";
      import { generateText } from "ai";
      import { openai } from "@ai-sdk/openai";
      import { v4 as uuidv4 } from "uuid";

      const composio = new Composio({
        apiKey: process.env.COMPOSIO_API_KEY,
        provider: new VercelProvider(),
      });

      const userId = uuidv4(); // The user's ID.

      const agenticTools = await composio.tools.get(
        userId,
        {
          tools: ["HACKERNEWS_GET_USER"],
        },
        {
          afterExecute: ({ toolSlug, toolkitSlug, result }) => {
            if (toolSlug === "HACKERNEWS_GET_USER") {
              const {
                data: { response_data: { karma } = {} } = {},
              } = result;
              return {
                ...result,
                data: { karma },
              };
            }
            return result;
          },
        }
      );

      ```
    </CodeGroup>
  </Tab>
</Tabs>


# Creating custom tools

> Learn how to extend Composio's toolkits with your own tools

Custom tools allow you to create your own tools that can be used with Composio.

1. Standalone tools - Simple tools that don't require any authentication
2. Toolkit-based tools - Tools that require authentication and can use toolkit credentials

## Creating a Custom Tool

### Standalone Tool

A standalone tool is the simplest form of custom tool. It only requires input parameters and an execute function:

<CodeGroup>
  ```python Python maxLines=60 wordWrap
  from pydantic import BaseModel, Field

  from composio import Composio
  from composio.types import ExecuteRequestFn

  composio = Composio()


  class AddTwoNumbersInput(BaseModel):
      a: int = Field(
          ...,
          description="The first number to add",
      )
      b: int = Field(
          ...,
          description="The second number to add",
      )

  # function name will be used as slug
  @composio.tools.custom_tool
  def add_two_numbers(request: AddTwoNumbersInput) -> int:
      """Add two numbers."""
      return request.a + request.b
  ```

  ```typescript TypeScript maxLines=60 wordWrap
  const tool = await composio.tools.createCustomTool({
    slug: 'CALCULATE_SQUARE',
    name: 'Calculate Square',
    description: 'Calculates the square of a number',
    inputParams: z.object({
      number: z.number().describe('The number to calculate the square of'),
    }),
    execute: async input => {
      const { number } = input;
      return {
        data: { result: number * number },
        error: null,
        successful: true,
      };
    },
  });
  ```
</CodeGroup>

### Toolkit-based Tool

A toolkit-based tool has access to two ways of making authenticated requests:

1. Using `executeToolRequest` - The recommended way to make authenticated requests to the toolkit's API endpoints. Composio automatically handles credential injection and baseURL resolution:

<CodeGroup>
  ```python Python maxLines=60 wordWrap
  class GetIssueInfoInput(BaseModel):
      issue_number: int = Field(
          ...,
          description="The number of the issue to get information about",
      )

  # function name will be used as slug
  @composio.tools.custom_tool(toolkit="github")
  def get_issue_info(
      request: GetIssueInfoInput,
      execute_request: ExecuteRequestFn,
      auth_credentials: dict,
  ) -> dict:
      """Get information about a GitHub issue."""
      response = execute_request(
          endpoint=f"/repos/composiohq/composio/issues/{request.issue_number}",
          method="GET",
          parameters=[
              {
                  "name": "Accept",
                  "value": "application/vnd.github.v3+json",
                  "type": "header",
              },
              {
                  "name": "Authorization",
                  "value": f"Bearer {auth_credentials['access_token']}",
                  "type": "header",
              },
          ],
      )
      return {"data": response.data}
  ```

  ```typescript TypeScript maxLines=60 wordWrap
  const tool = await composio.tools.createCustomTool({
    slug: 'GITHUB_STAR_COMPOSIOHQ_REPOSITORY',
    name: 'Github star composio repositories',
    toolkitSlug: 'github',
    description: 'Star any specified repo of `composiohq` user',
    inputParams: z.object({
      repository: z.string().describe('The repository to star'),
      page: z.number().optional().describe('Pagination page number'),
      customHeader: z.string().optional().describe('Custom header'),
    }),
    execute: async (input, connectionConfig, executeToolRequest) => {
      // This method makes authenticated requests to the relevant API
      // You can use relative paths!
      // Composio will automatically inject the baseURL
      const result = await executeToolRequest({
        endpoint: `/user/starred/composiohq/${input.repository}`,
        method: 'PUT',
        body: {},
        // Add custom headers or query parameters
        parameters: [
          // Add query parameters
          {
            name: 'page',
            value: input.page?.toString() || '1',
            in: 'query',
          },
          // Add custom headers
          {
            name: 'x-custom-header',
            value: input.customHeader || 'default-value',
            in: 'header',
          },
        ],
      });
      return result;
    },
  });
  ```
</CodeGroup>

2. Using `connectionConfig` - For making direct API calls when needed:

<CodeGroup>
  ```python Python maxLines=60 wordWrap
  import requests

  @composio.tools.custom_tool(toolkit="github")
  def get_issue_info_direct(
      request: GetIssueInfoInput,
      execute_request: ExecuteRequestFn,
      auth_credentials: dict,
  ) -> dict:
      """Get information about a GitHub issue."""
      response = requests.get(
          f"https://api.github.com/repos/composiohq/composio/issues/{request.issue_number}",
          headers={
              "Accept": "application/vnd.github.v3+json",
              "Authorization": f"Bearer {auth_credentials['access_token']}",
          },
      )
      return {"data": response.json()}
  ```

  ```typescript TypeScript maxLines=60 wordWrap
  const tool = await composio.tools.createCustomTool({
    slug: 'GITHUB_DIRECT_API',
    name: 'Direct GitHub API Call',
    description: 'Makes direct calls to GitHub API',
    toolkitSlug: 'github',
    inputParams: z.object({
      repo: z.string().describe('Repository name'),
    }),
    execute: async (input, connectionConfig, executeToolRequest) => {
      // Use connectionConfig for direct API calls
      const result = await fetch(`https://api.github.com/repos/${input.repo}`, {
        headers: {
          Authorization: `Bearer ${connectionConfig.access_token}`,
        },
      });

      return {
        data: await result.json(),
        error: null,
        successful: true,
      };

  },
  });

  ```
</CodeGroup>

### Using Custom Headers and Query Parameters

You can add custom headers and query parameters to your toolkit-based tools using the `parameters` option in `executeToolRequest`:

<CodeGroup>
  ```python Python maxLines=60 wordWrap
  @composio.tools.custom_tool(toolkit="github")
  def get_issue_info(
      request: GetIssueInfoInput,
      execute_request: ExecuteRequestFn,
      auth_credentials: dict,
  ) -> dict:
      """Get information about a GitHub issue."""
      response = execute_request(
          endpoint=f"/repos/composiohq/composio/issues/{request.issue_number}",
          method="GET",
          parameters=[
              {
                  "name": "Accept",
                  "value": "application/vnd.github.v3+json",
                  "type": "header",
              },
              {
                  "name": "Authorization",
                  "value": f"Bearer {auth_credentials['access_token']}",
                  "type": "header",
              },
              {
                  "name": 'X-Custom-Header',
                  "value": 'custom-value',
                  "type": 'header',
              },
          ],
      )
      return {"data": response.data}
  ```

  ```typescript TypeScript maxLines=60
  const tool = await composio.tools.createCustomTool({
    slug: 'GITHUB_SEARCH_REPOSITORIES',
    name: 'Search GitHub Repositories',
    description: 'Search for repositories with custom parameters',
    toolkitSlug: 'github',
    inputParams: z.object({
      query: z.string().describe('Search query'),
      perPage: z.number().optional().describe('Results per page'),
      acceptType: z.string().optional().describe('Custom accept header'),
    }),
    execute: async (input, connectionConfig, executeToolRequest) => {
      const result = await executeToolRequest({
        endpoint: '/search/repositories',
        method: 'GET',
        parameters: [
          // Add query parameters for pagination
          {
            name: 'q',
            value: input.query,
            in: 'query',
          },
          {
            name: 'per_page',
            value: (input.perPage || 30).toString(),
            in: 'query',
          },
          // Add custom headers
          {
            name: 'Accept',
            value: input.acceptType || 'application/vnd.github.v3+json',
            in: 'header',
          },
          {
            name: 'X-Custom-Header',
            value: 'custom-value',
            in: 'header',
          },
        ],
      });
      return result;
    },
  });
  ```
</CodeGroup>

## Executing Custom Tools

You can execute custom tools just like any other tool:

<CodeGroup>
  ```python Python maxLines=60 wordWrap
  response = composio.tools.execute(
      user_id="default",
      slug="TOOL_SLUG", # For the tool above you can use `get_issue_info.slug`
      arguments={"issue_number": 1},
  )
  ```

  ```typescript TypeScript maxLines=60 wordWrap
  const result = await composio.tools.execute('TOOL_SLUG', {
    arguments: {
      // Tool input parameters
    },
    userId: 'user-id',
    connectedAccountId: 'optional-account-id', // Required for toolkit-based tools
  });
  ```
</CodeGroup>

## Best Practices

1. Use descriptive names and slugs for your tools
2. Always provide descriptions for input parameters using `describe()`
3. Handle errors gracefully in your execute function
4. For toolkit-based tools:
   * Prefer `executeToolRequest` over direct API calls when possible
   * Use relative paths with `executeToolRequest` - Composio will automatically inject the correct baseURL
   * Use the `parameters` option to add custom headers or query parameters:
     ```typescript
     parameters: [
       { name: 'page', value: '1', in: 'query' }, // Adds ?page=1 to URL
       { name: 'x-custom', value: 'value', in: 'header' }, // Adds header
     ];
     ```
   * Remember that `executeToolRequest` can only call tools from the same toolkit
   * Use `executeToolRequest` to leverage Composio's automatic credential handling
   * Only use `connectionConfig` when you need to make direct API calls or interact with different services
5. Chain multiple toolkit operations using `executeToolRequest` for better maintainability

## Limitations

1. Custom tools are stored in memory and are not persisted
2. They need to be recreated when the application restarts
3. Toolkit-based tools require a valid connected account with the specified toolkit
4. `executeToolRequest` can only execute tools from the same toolkit that the custom tool belongs to
5. Each toolkit-based tool can only use one connected account at a time


# Custom Auth Configs

> Guide to customizing auth configs for a toolkit

Many toolkits support a level of customization for the auth config, specifically OAuth applications.

This guide will walk you through the process of customizing the auth config for toolkits where you can configure your own developer app.

## Creating a custom auth config

To create a custom auth config, click **Create Auth Config** in your dashboard, then navigate to **Authentication management** → **Manage authentication with custom credentials**.

You'll need to customize the auth config when you want to use different values than the defaults - such as your own subdomain, base URL, client ID, client secret, etc.

<Tabs>
  <Tab title="Example: PostHog">
    You may change the subdomain for the PostHog toolkit to match your own instance.

    <Frame background="subtle" title="PostHog Auth Config Settings">
      <img src="file:11a8bfe0-a750-41d1-8a76-225d0add9886" />
    </Frame>
  </Tab>

  <Tab title="Example: Hubspot">
    For Hubspot you may customize everything here. For each auth scheme there is a different set of fields.

    If you choose to use your own developer app for the OAuth2 scheme, you will have to provide the client ID and client secret.

    <Frame background="subtle" title="Hubspot Auth Config Settings">
      <img src="file:e78548c1-c960-41be-8e19-c3173cd324df" />
    </Frame>
  </Tab>
</Tabs>

Toolkits that support OAuth2 allow using your own developer app. This is the recommended approach for most cases.

<Tip title="Use your own developer app!" icon="exclamation">
  We recommend using your own developer app for the OAuth2 scheme as it is more suited for production usage with many users and more granular control over scopes.

  However, getting OAuth approvals takes time, so Composio provides a default developer app!
</Tip>

## OAuth2 Auth Configs

<Steps>
  <Step title="Generate the OAuth Client ID and Client Secret">
    To set up a custom OAuth config, you'll need the OAuth Client ID and Client Secret.

    You can generate the client ID and client secret from your provider's OAuth configuration page.

    Examples for Google and GitHub:

    <Tabs>
      <Tab title="Google">
        <Frame background="subtle" caption="Google OAuth Configuration">
          <img src="file:150ff46f-09f5-498c-87d4-0c5add07bcb9" />
        </Frame>
      </Tab>

      <Tab title="GitHub">
        <Frame background="subtle" caption="GitHub OAuth Configuration">
          <img src="file:5f619b2b-2540-47f4-a97b-6c376a3d405b" />
        </Frame>
      </Tab>
    </Tabs>
  </Step>

  <Step title="Set the Authorized Redirect URI">
    When creating your OAuth app, make sure to configure the Authorized Redirect URI to point to the Composio callback URL below:

    ```
    https://backend.composio.dev/api/v3/toolkits/auth/callback
    ```
  </Step>

  <Step title="Create the auth config">
    Once you have the OAuth credentials, you can add them to the auth config in the dashboard.

    1. Select the OAuth2 scheme.
    2. Select the scopes to request from users. Default scopes are pre-filled for most apps.
    3. Add the OAuth client ID and client secret for your developer app. Keep the redirect URL as is for now!
    4. Click Create!

    <Frame background="subtle" title="Auth Config Settings">
      <img src="file:d33a610c-be42-4014-9b0c-e18d46b74744" />
    </Frame>
  </Step>
</Steps>

This auth config is now ready to be used in your application!

<CodeGroup>
  ```python Python maxLines=60
  # Create a new connected account
  connection_request = composio.connected_accounts.initiate(
      user_id="user_id",
      auth_config_id="ac_1234",
  )
  print(connection_request)

  # Wait for the connection to be established
  connected_account = connection_request.wait_for_connection()
  print(connected_account)
  ```

  ```typescript TypeScript maxLines=60
  const connReq = await composio.connectedAccounts.initiate(userId, "ac_1234");

  console.log(connReq.redirectUrl);

  const connection = await composio.connectedAccounts.waitForConnection(
  connReq.id
  );

  console.log(connection);

  ```
</CodeGroup>

### White-labeling the OAuth Consent Screen

By default the users will see an OAuth screen like the one below:

<Frame background="subtle" caption="Composio's Domain in OAuth Consent Screen">
  <img src="file:7344ea04-1dc7-496c-bbe9-370e9decfc91" />
</Frame>

The OAuth redirect URL is surfaced in some OAuth providers' consent screens. This may cause confusion for some users as that URL is not of the same domain as the application.

To remediate this:

<Steps>
  <Step title="Set the Authorized Redirect URI">
    Specify the Authorized Redirect URI to your own domain in the OAuth configuration.
    For example:

    ```
    https://yourdomain.com/api/composio-redirect
    ```
  </Step>

  <Step title="Create a redirect logic">
    Create a redirect logic, either through your DNS or in your application to redirect that endpoint to `https://backend.composio.dev/api/v3/toolkits/auth/callback`

    **Example: API Route for OAuth Redirect**

    <CodeGroup>
      ```python FastAPI (app.py)
      from fastapi import FastAPI
      from fastapi.responses import RedirectResponse

      from composio import Composio

      # Create a FastAPI app
      app = FastAPI()

      # Create a Composio client
      composio = Composio()


      @app.get("/authorize/{toolkit}")
      def authorize_app(toolkit: str):
          # retrieve the user id from your app
          user_id = "<user_id>"

          # retrieve the auth config id from your app
          auth_config_id = "<auth_config_id>"

          # initiate the connection request
          connection_request = composio.connected_accounts.initiate(
              user_id=user_id,
              auth_config_id=auth_config_id,
          )
          return RedirectResponse(url=connection_request.redirect_url)
      ```

      ```typescript Next.js (pages/api/composio-redirect.ts)
      import type { NextApiRequest, NextApiResponse } from 'next';

      export default function handler(req: NextApiRequest, res: NextApiResponse) {
        // The target Composio endpoint that handles OAuth callbacks
        const composioEndpoint = 'https://backend.composio.dev/api/v3/toolkits/auth/callback';

      // Extract and preserve all query parameters
      const queryParams = new URLSearchParams();
      Object.entries(req.query).forEach(([key, value]) => {
      if (typeof value === 'string') {
      queryParams.append(key, value);
      }
      });

      // Redirect to Composio with all query parameters intact
      const redirectUrl = `${composioEndpoint}?${queryParams.toString()}`;
      res.redirect(302, redirectUrl);
      }

      ```
    </CodeGroup>
  </Step>

  <Step title="Create the auth config">
    Specify your custom redirect URI in the auth config settings!

    <Frame background="subtle" title="Auth Config Settings">
      <img src="file:2f108ed3-84f7-4ae2-a029-8ea16af74d50" />
    </Frame>
  </Step>
</Steps>

With this setup, you can use `https://yourdomain.com/api/composio-redirect` as your OAuth redirect URI, which will create a better user experience by keeping users on your domain during the OAuth flow.

<Accordion title="How does this work?">
  The custom OAuth config allows you to use your own domain in the OAuth consent screen instead of Composio's domain. Here's the core difference:

  ```mermaid
  flowchart TD
      A[Your App initiates OAuth] --> B[User redirected to OAuth Provider]
      B --> C{Redirect URI Configuration}

      C -->|Direct Setup| D[Provider redirects to<br />backend.composio.dev]
      C -->|Custom Domain| E[Provider redirects to<br />yourdomain.com/api/composio-redirect]

      E --> F[Your endpoint forwards to<br />backend.composio.dev]

      D --> G[Composio exchanges code for token]
      F --> G

      G --> H[Connection established]

      style E fill:#e1f5fe
      style F fill:#e1f5fe
      style C fill:#fff3e0
  ```

  **Key Benefits:**

  * **Custom Domain**: Users see your domain in OAuth consent screens, not Composio's
  * **Same Security**: Your domain just forwards the OAuth callback - no token handling
  * **Better UX**: Maintains brand consistency throughout the auth flow

  The custom redirect endpoint is a simple passthrough that preserves all OAuth parameters while keeping users on your domain.
</Accordion>


# Programmatic Auth Configs

> Guide to creating auth configs programmatically

Auth configs are created once and reused many times. However, when managing multiple toolkits, you may want to create auth configs programmatically.

* When creating and destroying auth configs multiple times in your app's lifecycle.
* When creating auth configs for your users' users.

## OAuth2 based apps

### Using Composio Default Auth

Since OAuth2 is the most common authentication type for applications, Composio provides managed auth for most OAuth2 based applications.
This is to speed up development and prototyping.
This means you don't have to provide your own OAuth credentials.

<CodeGroup>
  ```python Python maxLines=60  wordWrap
  from composio import Composio

  composio = Composio()

  # Use composio managed auth
  auth_config = composio.auth_configs.create(
      toolkit="github",
      options={
          "type": "use_composio_managed_auth",
      },
  )
  print(auth_config)
  ```

  ```typescript TypeScript maxLines=60  wordWrap {7}
  import { Composio } from "@composio/core";

  const composio = new Composio();

  const authConfig = await composio.authConfigs.create("GITHUB", {
    name: "GitHub",
    type: "use_composio_managed_auth",
  });

  console.log(authConfig);
  ```
</CodeGroup>

The returned `auth_config_id` should be stored securely in your database for future use to be created and destroyed multiple times.

You can also provide your own authentication details. The required `credentials` and `authScheme` depend on the auth type.

### Using your own OAuth2 credentials

Setting up and using your own OAuth2 credentials is the recommended way when going to production or expecting high usage.

In this example, we're using our own OAuth2 client ID and secret to create the auth config for Notion.

<CodeGroup>
  ```python Python maxLines=60 wordWrap {7}
  # Use custom auth
  auth_config = composio.auth_configs.create(
      toolkit="notion",
      options={
          "name": "Notion Auth",
          "type": "use_custom_auth",
          "auth_scheme": "OAUTH2",
          "credentials": {
              "client_id": "1234567890",
              "client_secret": "1234567890",
          },
      },
  )
  print(auth_config)
  ```

  ```typescript TypeScript maxLines=60  wordWrap {3}
  const authConfig = await composio.authConfigs.create("NOTION", {
      name: "Notion",
      type: "use_custom_auth",
      credentials: {
          client_id: "1234567890",
          client_secret: "1234567890",
      },
      authScheme: "OAUTH2",
  });

  console.log(authConfig);
  ```
</CodeGroup>

**Specifying the authorized redirect URI**
The process of setting up your own OAuth2 credentials usually involves generating a client ID and secret and specifying the **authorized redirect URI** in the OAuth configuration.

<Tip>
  The **authorized redirect URI** is the URI that captures the OAuth code that is returned to the app.
</Tip>

While doing so, you must ensure to set the **authorized redirect URI** in the OAuth configuration to:

```
https://backend.composio.dev/api/v3/toolkits/auth/callback
```

<Tabs>
  <Tab title="Redirect URI for GitHub">
    <Frame>
      <img src="file:b1608238-83c6-4a1d-8a07-94ac74dfe0c3" alt="Developer settings for GitHub OAuth2 app" />
    </Frame>
  </Tab>

  <Tab title="Redirect URI for Google">
    <Frame>
      <img src="file:4dd08dd6-d5ab-4276-adb1-1366a33c03cf" alt="Developer settings for Google OAuth2 app" />
    </Frame>
  </Tab>
</Tabs>

### Specifying scopes

Composio requests a set of appropriate default OAuth2 scopes for each toolkit wherever possible. However, you can override or modify these scopes by passing a `scopes` field to the `credentials` object.

<CodeGroup>
  ```python Python {11-13} title="Python" maxLines=40 
  from composio import Composio

  composio = Composio()

  response = composio.auth_configs.create(
      toolkit="HUBSPOT",
      options={
          "name": "HubspotConfig",
          "authScheme": "OAUTH2",
          "type": "use_composio_managed_auth",
          "credentials": {
              "scopes": "sales-email-read,tickets"
          }
      }
  )

  print(response.id)
  ```

  ```typescript TypeScript {8-10} title="TypeScript" maxLines=40 
  import { Composio } from "@composio/core";

  const composio = new Composio();

  const authConfig = await composio.authConfigs.create("HUBSPOT", {
    name: "HubspotConfig",
    type: "use_composio_managed_auth",
    credentials: {
      scopes: "sales-email-read,tickets",
    },
  });

  console.log(authConfig);
  ```
</CodeGroup>

## Other auth types

Composio supports many applications that use different authentication types like API keys, Bearer tokens, JWT and even no authentication at all.

Generating the auth config for other auth types only has minor differences.

* `use_custom_auth` is used instead of `use_composio_managed_auth`
* The `credentials` field is used to pass the authentication details
* The `authScheme` field is used to specify the auth type

<CodeGroup>
  ```python Python title="Python" maxLines=40 
  # Use custom auth
  auth_config = composio.auth_configs.create(
      toolkit="perplexityai",
      options={
          "type": "use_custom_auth",
          "auth_scheme": "API_KEY",
          "credentials": {}
      },
  )
  print(auth_config)

  ```

  ```typescript TypeScript title="TypeScript" maxLines=40 
  const authConfig = await composio.authConfigs.create('PERPLEXITYAI', {
    name: 'Perplexity AI',
    type: 'use_custom_auth',
    credentials: {},
    authScheme: 'API_KEY',
  });

  console.log(authConfig);

  ```
</CodeGroup>

## Programmatically inspecting fields

In cases where you need to dynamically discover the exact field names and handle different auth schemes programmatically, you can inspect the auth config details first.

This works for all auth types.

<CodeGroup>
  ```python Python maxLines=60  wordWrap
  required_fields = composio.toolkits.get_auth_config_creation_fields(
      toolkit="NOTION",
      auth_scheme="OAUTH2",
      required_only=True,
  )
  print(required_fields)
  ```

  ```typescript TypeScript maxLines=60
  const toolkits = await composio.toolkits.get("NOTION");

  // Extract field names from authConfigDetails
  const authFields = await composio.toolkits.getAuthConfigCreationFields('NOTION', 'OAUTH2', {
    requiredOnly: true,
  });

  console.log("Required auth config fields:", authFields);
  ```
</CodeGroup>

and then inspect the required fields and specify them in the `credentials` object.


# Custom Auth Parameters

> Guide to injecting custom credentials in headers or parameters for a toolkit

In cases where Composio is not being used for managing the auth but only for the tools, it is possible to use the `beforeExecute` hook to inject custom auth headers or parameters for a toolkit.

## Setup and Initialization

First, initialize the Composio SDK with your API key:

<CodeGroup>
  ```python Python maxLines=10
  from composio import Composio

  composio = Composio()
  ```

  ```typescript TypeScript maxLines=10
  import { Composio } from "@composio/core";

  const composio = new Composio({
    apiKey: process.env.COMPOSIO_API_KEY,
  });
  ```
</CodeGroup>

## Creating the Auth Modifier Function

Define a function that modifies authentication parameters for specific toolkits. This function checks the toolkit name and adds custom authentication headers when needed.

<Card title="This is a Before Execute Modifier!" href="/docs/modifying-tool-inputs" icon="fa-magic">
  Before Execute Modifiers are a way to modify the parameters of a tool before it is executed. In this case, they are useful for adding custom authentication headers or parameters to a tool.
</Card>

<CodeGroup>
  ```python Python maxLines=25
  from composio import before_execute
  from composio.types import ToolExecuteParams


  @before_execute(toolkits=["NOTION"])
  def add_custom_auth(
      tool: str,
      toolkit: str,
      params: ToolExecuteParams,
  ) -> ToolExecuteParams:
      if params["custom_auth_params"] is None:
          params["custom_auth_params"] = {"parameters": []}

      params["custom_auth_params"]["parameters"].append(
          {
              "name": "x-api-key",
              "value": os.getenv("NOTION_API_KEY"),
              "in": "header",
          }
      )
      return params
  ```

  ```typescript TypeScript maxLines=25
  const authModifier = (toolSlug: string, toolkitSlug: string, params: any) => {
    // Add authentication parameters for specific toolkits
    if (toolkitSlug === "NOTION") {
      if (!params.customAuthParams) {
        params.customAuthParams = {};
      }

      if (!params.customAuthParams.parameters) {
        params.customAuthParams.parameters = [];
      }

      // Add an API key to the headers
      params.customAuthParams.parameters.push({
        in: "header",
        name: "X-API-Key",
        value: process.env.CUSTOM_API_KEY,
      });
    }
    return params;
  };
  ```
</CodeGroup>

## Executing Tools with Custom Auth

Execute the tool using the custom authentication modifier. The `beforeExecute` hook allows you to modify parameters before the tool runs.

Following is an example of how to execute a tool with a custom authentication modifier for Completion Providers.

For Agentic Providers, read about [Modifying tool inputs](/docs/modifying-tool-inputs).

<CodeGroup>
  ```python Python maxLines=20
  result = composio.tools.execute(
      slug="NOTION_GET_DATABASE_ITEMS",
      user_id="default",
      arguments={},
      modifiers=[
          add_custom_auth,
      ],
  )
  print(result)
  ```

  ```typescript TypeScript maxLines=20
  const result = await composio.tools.execute(
    "NOTION_GET_DATABASE_ITEMS",
    {
      userId: "sid",
      arguments: {
        database_id: "1234567890",
      },
    },
    {
      beforeExecute: authModifier,
    }
  );

  console.log(JSON.stringify(result, null, 2));
  ```
</CodeGroup>


# User Management

> Learn how to manage users for your application

## What are User IDs?

User IDs determine whose connected accounts and data you're accessing in Composio. Every tool execution, connection authorization, and account operation
requires a `userId` parameter that identifies which context to use.

User IDs act as containers that group connected accounts together across toolkits. Depending on your application, you can use User IDs to represent an
individual user, a team, or an entire organization.

## Quick Decision Guide

**How do users access connected accounts in your app?**

* **Each user connects their own personal accounts?**\
  Use User IDs\
  *Use your database UUID or primary key (e.g., `user.id`)*\
  *Example: Users connect their personal Gmail, GitHub*

* **Teams share the same connected accounts?**\
  Use Organization IDs\
  *Use your organization UUID or primary key (e.g., `organization.id`)*\
  *Example: Company Slack workspace*

## Patterns

### User IDs (Individual Accounts)

In production applications with multiple users, where each user connects and manages their own accounts.

**Choosing User IDs:**

* Recommended: Database UUID or primary key (`user.id`)
* Acceptable: Unique username (`user.username`)
* Avoid: Email addresses (emails can change)

<CodeGroup>
  ```typescript Typescript
  // Use your database's user ID (UUID, primary key, etc.)
  const userId = user.id; // e.g., "550e8400-e29b-41d4-a716-446655440000"

  const tools = await composio.tools.get(userId, {
    toolkits: ['github'],
  });

  const result = await composio.tools.execute('GITHUB_GET_REPO', {
    userId: userId,
    arguments: { owner: 'example', repo: 'repo' },
  });
  ```

  ```python Python
  # Use your database's user ID (UUID, primary key, etc.)
  user_id = user.id; # e.g., "550e8400-e29b-41d4-a716-446655440000"

  tools = composio.tools.get(
    user_id=user_id,
    toolkits=["GITHUB"],
  )

  result = composio.tools.execute(
    "GITHUB_GET_REPO",
    user_id=user_id,
    arguments={ 
      "owner": 'example', 
      "repo": 'repo' 
    }
  )
  ```
</CodeGroup>

<Warning>
  Never use 'default' as an User ID in production with users. This could expose other users' data
</Warning>

### Organization IDs (Team Accounts)

For applications where teams share connections - one admin connects accounts, all team members use them.

**When to use:**

* Team tools: Slack, Microsoft Teams, Jira
* Shared accounts: support(at)company.com, company GitHub org
* Enterprise apps: IT manages connections for all employees

<CodeGroup>
  ```typescript TypeScript
  // Use the organization ID as userId
  const userId = organization.id; // e.g., "org_550e8400"

  // All users in the organization share the same connected accounts
  const tools = await composio.tools.get(userId, {
    toolkits: ['slack'],
  });

  // Execute tools in the organization context
  const result = await composio.tools.execute('SLACK_SEND_MESSAGE', {
    userId: userId,
    arguments: {
      channel: '#general',
      text: 'Hello from the team!',
    },
  });
  ```

  ```python Python
  # Use the organization ID as userId  
  user_id = organization.id # e.g., "org_550e8400"

  # All users in the organization share the same connected accounts
  tools = composio.tools.get(
    user_id=user_id,
    toolkits=["SLACK"],
  )

  # Execute tools in the organization context
  result = composio.tools.execute(
    "SLACK_SEND_MESSAGE",
    user_id=user_id,
    arguments={ 
      "channel": '#general', 
      "text": 'Hello from the team!' 
    }
  )
  ```
</CodeGroup>

## Multiple Connected Accounts

A single User ID can have multiple connected accounts for the same toolkit. For example, a user might connect both their personal and work Gmail accounts.

**Key concepts:**

* Each connected account gets a unique Connected Account ID
* Multiple accounts can exist under the same User ID for any toolkit
* You can specify which account to use when executing tools

**Account selection:**

* **Explicit:** Specify the Connected Account ID to target a specific account
* **Default:** If no Connected Account ID is provided, the most recently connected account is used

## Examples

### Organization-Based Application

In B2B applications, typically an admin connects accounts once and all team members share access. Here's a complete implementation:

**Key concepts:**

* Admin performs the OAuth connection using organization ID
* All team members execute tools using the same organization ID
* Permission checks ensure users can only access their organization's connections

```typescript TypeScript
import { Composio } from '@composio/core';
const composio = new Composio({
  apiKey: process.env.COMPOSIO_API_KEY,
});

// 1. Admin connects Slack for the entire organization
async function connectOrganizationToSlack(organizationId: string, adminUserId: string) {
  // Use organization ID as userId in Composio
  const connectionRequest = await composio.toolkits.authorize(organizationId, 'slack');
  
  // Store the connection request for the admin to complete
  await storeConnectionRequest(organizationId, adminUserId, connectionRequest);
  
  return connectionRequest.redirectUrl;
}

// 2. Any user in the organization can use the connected tools
async function sendSlackMessage(organizationId: string, channel: string, message: string) {
  return await composio.tools.execute('SLACK_SEND_MESSAGE', {
    userId: organizationId, // organization ID, not individual user ID
    arguments: {
      channel: channel,
      text: message,
    },
  });
}

// 3. Check if organization has required connections
async function getOrganizationTools(organizationId: string) {
  return await composio.tools.get(organizationId, {
    toolkits: ['slack', 'github', 'jira'],
  });
}

// Usage in your API endpoint
app.post('/api/slack/message', async (req, res) => {
  const { channel, message } = req.body;
  const organizationId = req.user.organizationId; // Get from your auth system
  
  // Verify user has permission to send messages for this organization
  // The userCanSendMessages function is your responsibility - implement it based on your application's permission model (role-based, feature flags, etc.).
  if (!(await userCanSendMessages(req.user.id, organizationId))) {
    return res.status(403).json({ error: 'Insufficient permissions' });
  }
  
  try {
    const result = await sendSlackMessage(organizationId, channel, message);
    res.json(result.data);
  } catch (error) {
    res.status(500).json({ error: 'Failed to send message' });
  }
});
```

### Multi-User Application

In B2C applications, each user connects and manages their own accounts. Every user goes through their own OAuth flow and their data remains completely isolated.

**Key concepts:**

* Each user authorizes their own accounts using their unique user ID
* Connections are isolated - users can only access their own connected accounts
* No permission checks needed since users only access their own data

```typescript TypeScript
import { Composio } from '@composio/core';
const composio = new Composio({
  apiKey: process.env.COMPOSIO_API_KEY,
});

// 1. User initiates GitHub connection
async function connectUserToGitHub(userId: string) {
  const connectionRequest = await composio.toolkits.authorize(userId, 'github');
  return connectionRequest.redirectUrl;
}

// 2. Get user's connected GitHub tools
async function getUserGitHubTools(userId: string) {
  return await composio.tools.get(userId, {
    toolkits: ['github'],
  });
}

// 3. Execute tool for specific user
async function getUserRepos(userId: string) {
  return await composio.tools.execute('GITHUB_LIST_REPOS', {
    userId: userId,
    arguments: {
      per_page: 10,
    },
  });
}

// Usage in your API endpoint
app.get('/api/github/repos', async (req, res) => {
  const userId = req.user.id; // Get from your auth system
  
  try {
    const repos = await getUserRepos(userId);
    res.json(repos.data);
  } catch (error) {
    res.status(500).json({ error: 'Failed to fetch repos' });
  }
});
```

**Data isolation**: Composio ensures each userId's connections and data are completely separate. User A can never access User B's repositories.

### Hybrid Pattern

Many applications need both personal and team resources. Users might connect their personal Gmail while sharing the company Slack workspace.

**Common scenarios:**

* Personal calendars + shared project management
* Individual GitHub accounts + organization repositories

<CodeGroup>
  ```typescript TypeScript
  // ❌ Wrong: Using individual user ID for org-connected tool
  const userTools = await composio.tools.get(req.user.id, {
    toolkits: ['slack'], // Fails - Slack is connected at org level
  });

  // ✅ Correct: Match the ID type to how the tool was connected
  const userPersonalTools = await composio.tools.get(req.user.id, {
    toolkits: ['gmail'], // User's personal Gmail
  });

  const orgSharedTools = await composio.tools.get(req.user.organizationId, {
    toolkits: ['slack', 'jira'], // Organization's shared tools
  });
  ```

  ```python Python 
  # ❌ Wrong: Using individual user ID for org-connected tool
  user_tools = composio.tools.get(
      user_id="user_123",  # Individual user ID
      toolkits=["slack"]  # Fails - Slack is connected at org level
  )

  # ✅ Correct: Match the ID type to how the tool was connected
  user_personal_tools = composio.tools.get(
      user_id="user_123",  # Individual user ID
      toolkits=["gmail"]  # User's personal Gmail
  )

  org_shared_tools = composio.tools.get(
      user_id="org_123",  # Organization ID
      toolkits=["slack", "jira"]  # Organization's shared tools  
  )
  ```
</CodeGroup>

Remember: The userId must match how the account was connected. If admin connected Slack with org ID, all members must use org ID to access it.

## Best Practices

**Your responsibilities:**

* Pass the correct User ID for each user
* Verify user permissions before executing organization tools
* Never use 'default' in production with multiple users
* Keep User IDs consistent across your application and Composio
* Use stable identifiers that won't change over time

**Data isolation:** Composio ensures complete isolation between User IDs. Users cannot access another ID's connections or data.


# Using Triggers

> Send payloads to your AI agents or systems based on events in apps.

When **events** occur in connected apps (like new Slack messages or GitHub commits), triggers automatically send the event data to your application.

Each event is delivered as a **structured payload** to your webhook endpoint (via webhooks or WebSockets), enabling your applications or AI agents to respond proactively.

<Frame caption="Triggers through Composio" background="subtle">
  ![Triggers Overview](file:fd349ce4-7e3c-4ad0-aa35-0a2ddae09eff)
</Frame>

<Tip title="Prerequisites">
  Before proceeding, ensure you've created an [auth
  config](/docs/authenticating-tools#creating-an-auth-config) and [established a
  connection](/docs/authenticating-tools#oauth-connections) to an app (e.g., Slack, GitHub).
  Triggers are scoped to specific users - learn about [User Management](/docs/user-management) for guidance on structuring User IDs.
</Tip>

## Creating a trigger

You can create triggers using either the Composio dashboard or programmatically via the SDK.

### Using dashboard

To create triggers through the **dashboard**:

* Navigate to the <a href="https://platform.composio.dev?next_page=%2Fauth-configs" target="_blank">Auth Configs</a> page
* Select the auth config
* Click "Add Trigger" and navigate to "Active Triggers" tab to fetch the trigger ID.
  <video src="file:faa15f84-a0eb-40f0-aed5-0db2ccfa545d" width="854" height="480" autoplay loop playsinline controls />

Some triggers require additional configuration. The dashboard will prompt you for any required fields during setup.

<Frame caption="Example: Gmail trigger configuration" background="subtle">
  <img src="file:799bc4eb-b9b0-4bfd-83d1-8e612b715438" alt="Trigger configuration example" width="400px" height="auto" />
</Frame>

### Using SDK

Create triggers programmatically by providing the trigger type and any required configuration.

<CodeGroup>
  ```python Python {12-16} title="Python" maxLines=40 
  from composio import Composio

  composio = Composio(api_key="your-api-key")
  user_id = "user-id-123435"

  # Check what configuration is required
  trigger_type = composio.triggers.get_type("GITHUB_COMMIT_EVENT")
  print(trigger_type.config)
  # Returns: {"properties": {...}, "required": ["owner", "repo"], ...}

  # Create trigger with the required config
  trigger = composio.triggers.create(
      slug="GITHUB_COMMIT_EVENT",
      user_id=user_id,
      trigger_config={"owner": "your-repo-owner", "repo": "your-repo-name"},
  )
  print(f"Trigger created: {trigger.trigger_id}")

  ```

  ```typescript TypeScript {12-21} title="TypeScript" maxLines=40 
  import { Composio } from '@composio/core';

  const composio = new Composio({apiKey: "your-api-key"});
  const userId = 'user-id-123435'; 

  // Check what configuration is required
  const triggerType = await composio.triggers.getType("GITHUB_COMMIT_EVENT");
  console.log(triggerType.config);
  // Returns: {"properties": {...}, "required": ["owner", "repo"], ...}

  // Create trigger with the required config
  const trigger = await composio.triggers.create(
      userId, 
      'GITHUB_COMMIT_EVENT', 
      {
          triggerConfig: {
              owner: 'your-repo-owner',
              repo: 'your-repo-name'
          }
      }
  );
  console.log(`Trigger created: ${trigger.triggerId}`);
  ```
</CodeGroup>

## Subscribing to triggers

### Webhooks

The recommended way to subscribe to triggers is through webhooks. Configure your webhook URL in the [Event & Trigger settings](https://platform.composio.dev?next_page=/settings/events).

Use a publicly accessible URL where Composio can send event payloads. This endpoint should be able to process incoming POST requests containing the trigger data.

<Tip>
  **Local development:** Use [ngrok](https://ngrok.com) or [webhook.site](https://webhook.site) to
  expose your local server to the internet for testing.
</Tip>

**Implement your webhook handler:**

Below are some examples of how to listen in on trigger events
for a FastAPI/Next.js application.

<CodeGroup>
  ```python Python title="app/route.py" maxLines=40 
  from fastapi import FastAPI, Request
  from typing import Dict, Any
  import uvicorn
  import json

  app = FastAPI(title="Webhook Demo")

  @app.post("/webhook")
  async def webhook_handler(request: Request):
      # Get the raw payload
      payload = await request.json()
      
      # Log the received webhook data
      print("Received webhook payload:")
      print(json.dumps(payload, indent=2))
      
      # Return a success response
      return {"status": "success", "message": "Webhook received"}

  if __name__ == "__main__":
      uvicorn.run(app, host="0.0.0.0", port=8000)


  ```

  ```typescript TypeScript title="app/api/webhook/route.ts" maxLines=40 
  import type { NextApiRequest, NextApiResponse } from 'next';
  import { TriggerEvent } from '@composio/core';

  // Define type-safe payload for GitHub Star Added event
  export type GitHubStarAddedEventPayload = {
    action: "created";
    repository_id: number;
    repository_name: string;
    repository_url: string;
    starred_at: string;
    starred_by: string;
  };

  // Type-safe handler function
  function handleGitHubStarAddedEvent(event: TriggerEvent<GitHubStarAddedEventPayload>) {
    console.log(`⭐ ${event.data.repository_name} starred by ${event.data.starred_by}`);
  }

  export default async function handler(req: NextApiRequest, res: NextApiResponse) {
    if (req.method !== 'POST') {
      return res.status(405).json({ 
        status: 'error', 
        message: 'Method not allowed. Only POST requests are accepted.' 
      });
    }

    try {
      const payload = req.body;
      
      // Type-safe webhook payload processing
      if (payload.triggerSlug === 'GITHUB_STAR_ADDED_EVENT') {
        const starEvent: TriggerEvent<GitHubStarAddedEventPayload> = {
          type: payload.triggerSlug,
          timestamp: new Date().toISOString(),
          data: {
            ...payload.payload as GitHubStarAddedEventPayload,
            connection_nano_id: payload.metadata?.connectedAccount?.id || '',
            trigger_nano_id: payload.id || '',
            user_id: payload.userId || '',
          }
        };
        
        handleGitHubStarAddedEvent(starEvent);
      }
      
      res.status(200).json({ 
        status: 'success', 
        message: 'Webhook received and processed successfully'
      });
    } catch (error) {
      console.error('Error processing webhook:', error);
      res.status(500).json({ 
        status: 'error', 
        message: 'Internal server error while processing webhook' 
      });
    }
  }

  ```
</CodeGroup>

### Prototyping with trigger subscriptions

During development, you can subscribe to triggers directly through the SDK without setting up webhooks.

You can subscribe to **multiple** trigger events by **configuring the filters**. When you specify multiple filters, ALL of them must match for the trigger to be subscribed to.

<CodeGroup>
  ```python Python title="Python" maxLines=40 
  from composio import Composio

  # Initialize Composio client
  composio = Composio(api_key="your_api_key_here")

  # Subscribe to trigger events
  subscription = composio.triggers.subscribe()

  # Define event handler
  @subscription.handle(trigger_id="your_trigger_id")
  def handle_github_commit(data):
    print(f"New commit detected: {data}")
    # Add your custom logic here

  # Note: For production use, set up webhooks instead

  ```

  ```typescript TypeScript title="Typescript" maxLines=40 
  import { Composio } from '@composio/core';

  // Initialize Composio client
  const composio = new Composio({ apiKey: "your_api_key_here" });

  // Subscribe to trigger events
  composio.triggers.subscribe(
    (data) => {
        console.log(`New commit detected:`, data);
        // Add your custom logic here
    },
    { triggerId: 'your_trigger_id'    
        // userId: 'user@acme.com',
        // toolkits: ['github', 'slack'],
        // triggerSlug: ["GITHUB_STAR_ADDED_EVENT"]
        // authConfigId: "ac_1234567890" }
    }
  );

  // Note: For production use, set up webhooks instead
  ```
</CodeGroup>

## Trigger payload types

To see what data you'll receive in your webhook handler, inspect the trigger's payload:

<CodeGroup>
  ```python Python maxLines=60 wordWrap
  # Get trigger type to inspect payload structure
  trigger = composio.triggers.get_type(slug="GITHUB_COMMIT_EVENT")
  print(trigger.payload)
  ```

  ```typescript TypeScript maxLines=60 wordWrap
  // Get trigger type to inspect payload structure
  const triggerType = await composio.triggers.getType('GITHUB_COMMIT_EVENT');

  console.log(triggerType.payload);
  ```
</CodeGroup>

### Type-safe trigger handling (TypeScript)

For better type safety and developer experience in TypeScript, you can define specific payload types and use the `TriggerEvent<T>` interface:

<CodeGroup>
  ```typescript TypeScript title="Type-safe trigger subscription" maxLines=40 
  // Define type-safe payload for GitHub Star Added event
  export type GitHubStarAddedEventPayload = {
    action: "created";
    repository_id: number;
    repository_name: string;
    repository_url: string;
    starred_at: string;
    starred_by: string;
  };

  const composio = new Composio();
  const userId = 'user@acme.com';

  // Create the trigger
  const createResponse = await composio.triggers.create(userId, 'GITHUB_STAR_ADDED_EVENT', {
    triggerConfig: {
      owner: 'composiohq',
      repo: 'composio',
    },
  });

  // Fetch trigger type details
  const triggerType = await composio.triggers.getType("GITHUB_STAR_ADDED_EVENT");
  console.log(triggerType.config);
  ```

  ```typescript TypeScript title="Type-safe webhook handling" maxLines=40 

  // Define type-safe payload for GitHub Star Added event
  export type GitHubStarAddedEventPayload = {
    action: "created";
    repository_id: number;
    repository_name: string;
    repository_url: string;
    starred_at: string;
    starred_by: string;
  };

  // Type-safe handler function
  function handleGitHubStarAddedEvent(event: TriggerEvent<GitHubStarAddedEventPayload>) {
    console.log(`⭐ ${event.data.repository_name} starred by ${event.data.starred_by}`);
  }

  ```
</CodeGroup>

This approach provides:

* **IntelliSense support** for trigger payload fields
* **Compile-time error checking** for typos and invalid field access
* **Better documentation** through TypeScript types
* **Improved maintainability** of trigger handling code

## Managing triggers

### Enable/disable triggers

You can pause triggers temporarily without deleting them.

<Tabs>
  <Tab title="Dashboard">
    1. Go to the [Auth Config](https://platform.composio.dev?next_page=/auth-configs) page
    2. Select your auth config
    3. Navigate to "Active Triggers"
    4. Disable/Enable the trigger

    <Frame caption="Enable/disable triggers" background="subtle">
      <img src="file:396d15cc-216a-402a-93b8-3e56a697db1d" alt="Enable/disable triggers" width="400px" height="auto" />
    </Frame>
  </Tab>

  <Tab title="SDK">
    <CodeGroup>
      ```python Python
      # Disable a trigger
      composio.triggers.disable(trigger_id="ti_abcd123")

      # Re-enable when needed

      composio.triggers.enable(trigger_id="ti_abcd123")

      ```

      ```typescript TypeScript
      // Disable a trigger
      await composio.triggers.disable('ti_abcd123');

      // Re-enable when needed
      await composio.triggers.enable('ti_abcd123');

      ```
    </CodeGroup>
  </Tab>
</Tabs>

## Troubleshooting

View detailed trigger logs and debug issues on the [Composio dashboard](https://platform.composio.dev?next_page=/logs/triggers).

```
```


# MCP quickstart

> Create your first MCP server

[Model Context Protocol](https://modelcontextprotocol.io/introduction) (MCP) is an open-source standard for connecting AI applications to external tools. All the 500+ tools available in Composio are also available as MCP servers.

Composio lets you create MCP servers that handle authentication (OAuth, API keys), generate unique URLs for each user, and control which tools are exposed. You can combine multiple toolkits in a single server.

<Note>
  Composio MCP servers only support Streamable HTTP transport.
</Note>

## Install the SDK

First, install the Composio SDK for your preferred language:

<CodeGroup>
  ```bash title="Python" for="python"
  pip install composio
  ```

  ```bash title="TypeScript" for="typescript"
  npm install @composio/core
  ```
</CodeGroup>

## Create an MCP server

<Steps>
  <Step title="Initialize Composio">
    <CodeGroup>
      ```python Python title="Python" maxLines=40 
      from composio import Composio

      # Initialize Composio
      composio = Composio(api_key="YOUR_API_KEY")
      ```

      ```typescript TypeScript title="TypeScript" maxLines=40 
      import { Composio } from '@composio/core';

      // Initialize Composio
      const composio = new Composio({
      apiKey: process.env.COMPOSIO_API_KEY
      });
      ```
    </CodeGroup>
  </Step>

  <Step title="Create server configuration">
    <Warning>
      **Before you begin:** [Create an auth configuration](/docs/authenticating-tools#creating-an-auth-config) for your toolkit.
    </Warning>

    Create an MCP server with your auth config. You can also set list of specific tools to enable across all toolkits

    <CodeGroup>
      ```python Python title="Python" maxLines=40 
      # Create MCP server with multiple toolkits
      server = composio.mcp.create(
      name="mcp-config-73840", # Pick a unique name for your MCP server
      toolkits=[
          {
              "toolkit": "gmail",
              "auth_config": "ac_xyz123"  # Your Gmail auth config ID
          },
          {
              "toolkit": "googlecalendar",
              "auth_config": "ac_abc456"  # Your Google Calendar auth config ID
          }
      ],
      allowed_tools=["GMAIL_FETCH_EMAILS", "GMAIL_SEND_EMAIL", "GOOGLECALENDAR_EVENTS_LIST"]
      )

      print(f"Server created: {server.id}")
      ```

      ```typescript TypeScript title="TypeScript" maxLines=40 
      // Create MCP server with multiple toolkits
      const server = await composio.mcp.create("mcp-config-73840", {  // Pick a unique name for your MCP server
      toolkits: [
      {
        authConfigId: "ac_xyz123", // Your Gmail auth config ID
        toolkit: "gmail"
      },
      {
        authConfigId: "ac_abc456", // Your Google Calendar auth config ID
        toolkit: "googlecalendar"
      }
      ],
      allowedTools: ["GMAIL_FETCH_EMAILS", "GMAIL_SEND_EMAIL", "GOOGLECALENDAR_EVENTS_LIST"]
      });

      console.log(`Server created: ${server.id}`);
      ```
    </CodeGroup>

    <Note>
      **Alternative:** You can also create and manage MCP configs directly from the [Composio dashboard → MCP Configs](https://platform.composio.dev?next_page=/mcp-configs).
    </Note>
  </Step>

  <Step title="Generate user URLs">
    <Warning>
      **Before generating URLs:** Users must authenticate with the toolkits configured in your MCP server. See [hosted authentication](/docs/authenticating-tools#hosted-authentication-connect-link) for how to connect user accounts.
    </Warning>

    Get server URLs for your users to connect:

    <CodeGroup>
      ```python Python title="Python" maxLines=40 

      # Generate server instance for user
      instance = composio.mcp.generate(user_id="user-73840", mcp_config_id=server.id) # Use the user ID for which you created the connected account

      print(f"MCP Server URL: {instance['url']}")
      ```

      ```typescript TypeScript title="TypeScript" maxLines=40 

      // Generate server instance for user
      const instance = await composio.mcp.generate("user-73840", server.id);  // Use the user ID for which you created the connected account

      console.log("MCP Server URL:", instance.url);
      ```
    </CodeGroup>

    <Note>
      If users haven't authenticated, the MCP server will still generate a URL but tools requiring authentication won't work until the user connects their accounts.
    </Note>
  </Step>

  <Step title="Use with AI providers">
    Use the MCP server URL with your AI provider:

    <CodeGroup>
      ```python Python title="OpenAI (Python)" maxLines=40 
      from openai import OpenAI

      # Initialize OpenAI client
      client = OpenAI(api_key="your-openai-api-key")

      # Use the MCP server URL you generated
      mcp_server_url = "https://backend.composio.dev/v3/mcp/YOUR_SERVER_ID?include_composio_helper_actions=true&user_id=YOUR_USER_ID"

      # Use MCP with OpenAI Responses API
      response = client.responses.create(
      model="gpt-5",
      tools=[
          {
              "type": "mcp",
              "server_label": "composio-server",  
              "server_description": "Composio MCP server for Gmail and Calendar integrations",
              "server_url": mcp_server_url,
              "require_approval": "never",
          },
      ],
      input="What meetings do I have tomorrow? Also check if I have any urgent emails",
      )

      print("OpenAI MCP Response:", response.output_text)
      ```

      ```python Python title="Anthropic (Python)" maxLines=40 
      from anthropic import Anthropic

      # Initialize Anthropic client
      client = Anthropic(api_key="your-anthropic-api-key")

      # Use the MCP server URL you generated
      mcp_server_url = "https://backend.composio.dev/v3/mcp/YOUR_SERVER_ID?include_composio_helper_actions=true&user_id=YOUR_USER_ID"

      # Use MCP with Anthropic (beta feature)
      response = client.beta.messages.create(
      model="claude-sonnet-4-5",
      system="You are a helpful assistant with access to various tools through MCP. Use these tools to help the user. Do not ask for confirmation before using the tools.",
      max_tokens=1000,
      messages=[{
          "role": "user",
          "content": "What meetings do I have tomorrow? Also check if I have any urgent emails"
      }],
      mcp_servers=[{
          "type": "url",
          "url": mcp_server_url,
          "name": "composio-gmail-calendar-mcp-server"
      }],
      betas=["mcp-client-2025-04-04"]  # Enable MCP beta
      )

      print(response.content)
      ```

      ```typescript TypeScript title="Mastra (TypeScript)" maxLines=40 
      import { MCPClient } from "@mastra/mcp";
      import { openai } from "@ai-sdk/openai";
      import { Agent } from "@mastra/core/agent";

      // Use the MCP server URL you generated
      const MCP_URL = "https://backend.composio.dev/v3/mcp/YOUR_SERVER_ID?include_composio_helper_actions=true&user_id=YOUR_USER_ID";

      export const client = new MCPClient({
      id: "docs-mcp-client",
      servers: {
      composio: { url: new URL(MCP_URL) },
      }
      });

      export const agent = new Agent({
      name: "Assistant",
      description: "Helpful AI with MCP tools",
      instructions: "Use the MCP tools to answer.",
      model: openai("gpt-4-turbo"),
      tools: await client.getTools()
      });

      (async () => {
      const res = await agent.generate("What meetings do I have tomorrow? Also check if I have any urgent emails");
      console.log(res.text);
      })();
      ```
    </CodeGroup>
  </Step>
</Steps>

## Next steps

<Cards>
  <Card title="Authentication" href="/docs/mcp-authentication" icon="lock">
    Handle user authentication and connections
  </Card>

  <Card title="Server management" href="/docs/mcp-server-management" icon="server">
    Create and manage MCP servers
  </Card>

  <Card title="Providers" href="/docs/mcp-providers" icon="code">
    Use with Anthropic, OpenAI, and other frameworks
  </Card>
</Cards>

<Tip>
  Need help? Join our [Discord](https://discord.com/invite/composio) or [raise an issue on GitHub](https://github.com/ComposioHQ/composio/issues/new?labels=bug).
</Tip>


# Server management

> Create, update, and manage MCP servers

This guide covers all server management operations for MCP servers.

## Create a server

<CodeGroup>
  <CodeGroupItem title="Python">
    ```python
    server = composio.mcp.create(
        name="my-gmail-server",
        toolkits=[{
            "toolkit": "gmail",
            "auth_config": "ac_xyz123"
        }],
        allowed_tools=["GMAIL_FETCH_EMAILS", "GMAIL_SEND_EMAIL"]
    )

    print(f"Created server: {server.id}")
    ```
  </CodeGroupItem>

  <CodeGroupItem title="TypeScript">
    ```typescript
    const server = await composio.mcp.create(
      "my-gmail-server",
      {
        toolkits: [
          {
            authConfigId: "ac_xyz123",
            toolkit: "gmail"
          }
        ],
        allowedTools: ["GMAIL_FETCH_EMAILS", "GMAIL_SEND_EMAIL"],
        manuallyManageConnections: false
      }
    );

    console.log(`Created server: ${server.id}`);
    ```
  </CodeGroupItem>
</CodeGroup>

## List servers

Find and filter your MCP servers.

<CodeGroup>
  <CodeGroupItem title="Python">
    ```python
    # List all servers
    servers = composio.mcp.list()
    print(f"Found {len(servers['items'])} servers")

    # Filter by toolkit
    gmail_servers = composio.mcp.list(
        toolkits="gmail",
        limit=20
    )

    # Filter by name
    production_servers = composio.mcp.list(
        name="production"
    )
    ```
  </CodeGroupItem>

  <CodeGroupItem title="TypeScript">
    ```typescript
    // List all servers
    const servers = await composio.mcp.list({
      limit: 10,
      page: 1,
      authConfigs: [],
      toolkits: []
    });
    console.log(`Found ${servers.items.length} servers`);

    // Filter by toolkit
    const gmailServers = await composio.mcp.list({
      limit: 20,
      page: 1,
      authConfigs: [],
      toolkits: ["gmail"]
    });

    // Filter by name
    const productionServers = await composio.mcp.list({
      limit: 10,
      page: 1,
      authConfigs: [],
      toolkits: [],
      name: "production"
    });
    ```
  </CodeGroupItem>
</CodeGroup>

## Get server details

<CodeGroup>
  <CodeGroupItem title="Python">
    ```python
    # Get by ID
    server = composio.mcp.get("mcp_server_id")
    print(f"Server name: {server.name}")
    print(f"Toolkits: {server.toolkits}")
    ```
  </CodeGroupItem>

  <CodeGroupItem title="TypeScript">
    ```typescript
    // Get by ID
    const server = await composio.mcp.get("mcp_server_id");

    console.log(`Server: ${server.name}`);
    console.log(`Toolkits: ${server.toolkits}`);
    ```
  </CodeGroupItem>
</CodeGroup>

## Update a server

Modify server configuration, tools, or auth configs.

<CodeGroup>
  <CodeGroupItem title="Python">
    ```python
    updated = composio.mcp.update(
        server_id="mcp_server_id",
        name="updated-name",
        allowed_tools=["GMAIL_FETCH_EMAILS", "GMAIL_SEARCH_EMAILS"]
    )
    ```
  </CodeGroupItem>

  <CodeGroupItem title="TypeScript">
    ```typescript
    const updated = await composio.mcp.update(
      "mcp_server_id",
      {
        name: "updated-name",
        toolkits: [
          {
            toolkit: "gmail",
            authConfigId: "ac_new_config"
          }
        ],
        allowedTools: ["GMAIL_FETCH_EMAILS", "GMAIL_SEARCH_EMAILS"],
        manuallyManageConnections: false
      }
    );

    console.log(updated);
    ```
  </CodeGroupItem>
</CodeGroup>

## Delete a server

<CodeGroup>
  <CodeGroupItem title="Python">
    ```python
    result = composio.mcp.delete("mcp_server_id")
    if result['deleted']:
        print("Server deleted successfully")
    ```
  </CodeGroupItem>

  <CodeGroupItem title="TypeScript">
    ```typescript
    const result = await composio.mcp.delete("mcp_server_id");
    if (result.deleted) {
      console.log("Server deleted successfully");
    }
    ```
  </CodeGroupItem>
</CodeGroup>

## Multi-toolkit servers

Combine multiple services in a single MCP server.

<CodeGroup>
  <CodeGroupItem title="Python">
    ```python
    server = composio.mcp.create(
        name="productivity-suite",
        toolkits=[
            {"toolkit": "gmail", "auth_config": "ac_gmail"},
            {"toolkit": "slack", "auth_config": "ac_slack"},
            {"toolkit": "github", "auth_config": "ac_github"}
        ],
        allowed_tools=[
            "GMAIL_FETCH_EMAILS",
            "SLACK_SEND_MESSAGE",
            "GITHUB_CREATE_ISSUE"
        ]
    )
    ```
  </CodeGroupItem>

  <CodeGroupItem title="TypeScript">
    ```typescript
    const server = await composio.mcp.create(
      "productivity-suite",
      {
        toolkits: [
          { 
            authConfigId: "ac_gmail",
            toolkit: "gmail"
          },
          { 
            authConfigId: "ac_slack",
            toolkit: "slack"
          },
          { 
            authConfigId: "ac_github",
            toolkit: "github"
          }
        ],
        allowedTools: [
          "GMAIL_FETCH_EMAILS",
          "SLACK_SEND_MESSAGE",
          "GITHUB_CREATE_ISSUE"
        ],
        manuallyManageConnections: false
      }
    );
    ```
  </CodeGroupItem>
</CodeGroup>

## Generate user URLs

After creating a server, generate unique URLs for each user.

<CodeGroup>
  <CodeGroupItem title="Python">
    ```python
    # Generate instance for user
    instance = server.generate("user@example.com")

    print(f"URL: {instance['url']}")
    print(f"Tools: {instance['allowed_tools']}")

    # Chat-based authentication is enabled by default
    # Set manually_manage_connections=True to disable it:
    instance_manual = server.generate(
        "user@example.com", 
        manually_manage_connections=True
    )
    ```
  </CodeGroupItem>

  <CodeGroupItem title="TypeScript">
    ```typescript
    // Generate instance for user
    const instance = await server.generate("user@example.com");

    console.log("URL:", instance.url);
    console.log("Tools:", instance.allowedTools);

    // Chat-based authentication is enabled by default
    // Set manuallyManageConnections: true to disable it:
    const instanceManual = await composio.mcp.generate(
      "user@example.com",
      server.id,
      { manuallyManageConnections: true }
    );
    ```
  </CodeGroupItem>
</CodeGroup>

<Note>
  **Chat-based authentication:**

  * **TypeScript**: Enabled by default (set `manuallyManageConnections=false` or omit it)
  * **Python**: Enabled by default (set `manually_manage_connections=False` or omit it)

  When enabled, the agent can authenticate users dynamically during conversation if they're missing required connections. Set `manuallyManageConnections=true` (TypeScript) or `manually_manage_connections=True` (Python) to disable it.
</Note>

## Best practices

* **Use descriptive names** - Makes servers easy to find
* **Limit tools appropriately** - Only include necessary tools
* **Reuse servers** - Don't create duplicates for same configuration
* **Store server IDs** - Keep track of created server IDs


# Provider integrations

> Connect MCP servers to AI frameworks

Integrate your MCP servers with popular AI SDKs and frameworks.

<Note>
  Composio MCP servers only support Streamable HTTP transport.
</Note>

## Anthropic SDK

Use MCP servers with the Anthropic Claude API.

<CodeGroup>
  <CodeGroupItem title="Python">
    ```python Python title="Python" maxLines=40 
    from anthropic import Anthropic
    from composio import Composio

    # Initialize clients
    composio = Composio()
    anthropic = Anthropic(api_key="your-anthropic-api-key")

    # Create MCP server with GitHub and Linear tools
    server = composio.mcp.create(
        name="dev-workflow-server",
        toolkits=[
            {"toolkit": "github", "auth_config": "ac_github_id"},
            {"toolkit": "linear", "auth_config": "ac_linear_id"}
        ],
        allowed_tools=["GITHUB_LIST_PRS", "GITHUB_CREATE_COMMENT", "LINEAR_CREATE_ISSUE"]
    )

    # Generate MCP instance for user
    instance = server.generate("user@example.com")

    # Use MCP with Anthropic to manage development workflow
    response = anthropic.beta.messages.create(
        model="claude-sonnet-4-5",
        system="You are a helpful assistant with access to GitHub and Linear tools. Use these tools to help manage development workflows. Do not ask for confirmation before using the tools.",
        max_tokens=1000,
        messages=[{
            "role": "user",
            "content": "Check my GitHub PRs for review comments, create Linear tasks for any requested changes, and update the PR descriptions with task links"
        }],
        mcp_servers=[{
            "type": "url",
            "url": instance['url'],
            "name": "composio-mcp-server"
        }],
        betas=["mcp-client-2025-04-04"]  # Enable MCP beta
    )

    print(response.content)
    ```
  </CodeGroupItem>

  <CodeGroupItem title="TypeScript">
    ```typescript TypeScript title="TypeScript" maxLines=40 
    import Anthropic from '@anthropic-ai/sdk';
    import { Composio } from '@composio/core';

    // Initialize clients
    const composio = new Composio();
    const anthropic = new Anthropic({
      apiKey: process.env.ANTHROPIC_API_KEY,
    });

    // Create MCP server with Google Sheets tools
    const server = await composio.mcp.create(
      "analytics-server",
      {
        toolkits: [
          { toolkit: "googlesheets", authConfigId: "ac_sheets_id" }
        ],
        allowedTools: ["GOOGLESHEETS_GET_DATA", "GOOGLESHEETS_UPDATE_DATA", "GOOGLESHEETS_CREATE_SHEET"]
      }
    );

    // Generate MCP instance for user
    const instance = await server.generate("user@example.com");

    // Use MCP with Anthropic for spreadsheet operations
    const response = await anthropic.beta.messages.create({
      model: "claude-sonnet-4-5",
      system: "You are a helpful assistant with access to Google Sheets tools. Use these tools to analyze and manage spreadsheet data. Do not ask for confirmation before using the tools.",
      max_tokens: 1000,
      messages: [{
        role: "user",
        content: "Analyze the sales data in my Google Sheets 'Q4 Revenue' spreadsheet, calculate month-over-month growth, and add a new summary sheet with visualizations"
      }],
      mcp_servers: [{
        type: "url",
        url: instance.url,
        name: "composio-mcp-server"
      }],
      betas: ["mcp-client-2025-04-04"]  // Enable MCP beta
    });

    console.log(response.content);
    ```
  </CodeGroupItem>
</CodeGroup>

## OpenAI SDK

Integrate MCP servers with OpenAI GPT models.

<CodeGroup>
  <CodeGroupItem title="Python">
    ```python Python title="Python" maxLines=40 
    from openai import OpenAI
    from composio import Composio

    # Initialize clients
    composio = Composio()
    openai = OpenAI(api_key="your-openai-api-key")

    # Create MCP server with Google Sheets and Notion tools
    server = composio.mcp.create(
        name="data-docs-server",
        toolkits=[
            {"toolkit": "googlesheets", "auth_config": "ac_sheets_id"},
            {"toolkit": "notion", "auth_config": "ac_notion_id"}
        ],
        allowed_tools=["GOOGLESHEETS_GET_DATA", "GOOGLESHEETS_UPDATE_DATA", "NOTION_CREATE_PAGE"]
    )

    # Generate MCP instance for user
    instance = server.generate("user@example.com")

    # Use MCP with OpenAI for data management
    response = openai.responses.create(
        model="gpt-5",
        tools=[
            {
                "type": "mcp",
                "server_label": "composio-server",  
                "server_description": "Composio MCP server with Google Sheets and Notion integrations",
                "server_url": instance['url'],
                "require_approval": "never",
            },
        ],
        input="Export the Q4 metrics from Google Sheets and create a comprehensive Notion page with charts and analysis",
    )

    print("OpenAI MCP Response:", response.output_text)
    ```
  </CodeGroupItem>

  <CodeGroupItem title="TypeScript">
    ```typescript TypeScript title="TypeScript" maxLines=40 
    import OpenAI from 'openai';
    import { Composio } from '@composio/core';

    // Initialize clients
    const composio = new Composio();
    const openai = new OpenAI({
      apiKey: process.env.OPENAI_API_KEY,
    });

    // Create MCP server with Linear and Notion tools
    const server = await composio.mcp.create(
      "project-docs-server",
      {
        toolkits: [
          { toolkit: "linear", authConfigId: "ac_linear_id" },
          { toolkit: "notion", authConfigId: "ac_notion_id" }
        ],
        allowedTools: ["LINEAR_LIST_ISSUES", "LINEAR_GET_ISSUE", "NOTION_CREATE_PAGE"]
      }
    );

    // Generate MCP instance for user
    const instance = await server.generate("user@example.com");

    // Use MCP with OpenAI for project documentation
    const response = await openai.responses.create({
      model: "gpt-5",
      tools: [
        {
          type: "mcp",
          server_label: "composio-server",
          server_description: "Composio MCP server with Linear and Notion integrations",
          server_url: instance.url,
          require_approval: "never",
        },
      ],
      input: "Find all completed Linear issues from this sprint and create a Notion page documenting the release notes",
    });

    console.log("OpenAI MCP Response:", response.output_text);
    ```
  </CodeGroupItem>
</CodeGroup>

## Mastra

Use MCP servers with Mastra framework.

```typescript TypeScript title="TypeScript" maxLines=40 
import { MCPClient } from "@mastra/mcp";
import { openai } from "@ai-sdk/openai";
import { Agent } from "@mastra/core/agent";
import { Composio } from "@composio/core";

// Initialize Composio
const composio = new Composio();

// Create MCP server with GitHub, Linear, and Notion tools
const server = await composio.mcp.create(
  "dev-automation-server",
  {
    toolkits: [
      { toolkit: "github", authConfigId: "ac_github_id" },
      { toolkit: "linear", authConfigId: "ac_linear_id" },
      { toolkit: "notion", authConfigId: "ac_notion_id" }
    ],
    allowedTools: [
      "GITHUB_LIST_ISSUES", "GITHUB_CREATE_ISSUE",
      "LINEAR_CREATE_ISSUE", "LINEAR_UPDATE_ISSUE",
      "NOTION_CREATE_PAGE", "NOTION_UPDATE_PAGE"
    ]
  }
);

// Generate MCP instance for user
const instance = await server.generate("user@example.com");

// Create MCP client with Composio server
export const mcpClient = new MCPClient({
  id: "composio-mcp-client",
  servers: {
    composio: { url: new URL(instance.url) },
  }
});

// Create a development workflow agent
export const devAgent = new Agent({
  name: "Dev Assistant",
  description: "AI assistant for development workflow automation",
  instructions: "Help manage GitHub repos, Linear issues, and Notion documentation.",
  model: openai("gpt-4-turbo"),
  tools: await mcpClient.getTools()
});

// Example: Automate development workflow
(async () => {
  const response = await devAgent.generate(
    "Review open GitHub issues, create Linear tasks for bugs labeled 'priority', and update the Notion roadmap page"
  );
  console.log(response.text);
})();
```


# Composio Partner Program

> Onboard as a partner with Composio

Composio has launched the **MCP Partner Program** — a simple way to get access to pre-configured MCP servers for over 200+ toolkits. Perfect for platforms and developers looking to distribute MCP servers to their own users with zero setup.

<Tip>
  Want to embed ready-to-use MCP servers in your own clients or workflows? Join the partner program and get access instantly.
</Tip>

### What do partners get?

As a partner, you receive:

* **Access to curated MCP servers** for all supported toolkits
* **One simple API** to fetch all the MCP servers linked to your partner org
* **No infrastructure management or custom config required**

It's the fastest way to plug MCP into your platform.

### Getting started is easy

Just send an email to **[thomas@composio.dev](mailto:thomas@composio.dev)** and we'll onboard you.

Once onboarded, you'll get a unique API URL to fetch your MCP servers.

#### Example

If your company is called `lemon`, you can fetch your available MCP servers with:

```bash
GET https://mcp.composio.dev/api/partner/lemon/apps/list

```

#### Complete example

Here's a full curl request to fetch your MCP servers:

```bash
curl -X GET https://mcp.composio.dev/api/partner/lemon/apps/list \
  -H "Content-Type: application/json"
```

**Sample response:**

```json
{
  "items": [
    {
      "slug": "gmail",
      "name": "Gmail",
      "description": "Gmail is Google's email service, featuring spam protection, search functions, and seamless integration with other G Suite apps for productivity",
      "category": [
        "collaboration & communication"
      ],
      "logo": "https://cdn.jsdelivr.net/gh/ComposioHQ/open-logos@master/gmail.svg",
      "mcp_url": "https://mcp.composio.dev/partner/lemon/gmail",
      "tool_count": 23
    },
    {
      "slug": "slack",
      "name": "Slack",
      "description": "Slack is a business communication platform offering organized conversations in channels, direct messaging, and integrations with third-party services",
      "category": [
        "collaboration & communication"
      ],
      "logo": "https://cdn.jsdelivr.net/gh/ComposioHQ/open-logos@master/slack.svg",
      "mcp_url": "https://mcp.composio.dev/partner/lemon/slack",
      "tool_count": 15
    },
    {
      "slug": "github",
      "name": "GitHub",
      "description": "GitHub is a web-based platform for version control and collaboration using Git, allowing developers to store, manage, and share code repositories",
      "category": [
        "development"
      ],
      "logo": "https://cdn.jsdelivr.net/gh/ComposioHQ/open-logos@master/github.svg",
      "mcp_url": "https://mcp.composio.dev/partner/lemon/github",
      "tool_count": 42
    }
  ]
}
```


# Tool Router Quick Start

> Learn how to use tool router to route tool calls to the correct tool.

Tool Router automatically discovers, authenticates, and executes the right tools for any task. It's an experimental feature that handles the entire workflow—from finding relevant tools across 500+ integrations to managing authentication and parallel execution.

This is what powers complex agentic products like [Rube](https://rube.app).

## Quick start

<Steps toc={true}>
  <Step title="Install SDKs">
    Install the Composio SDK and OpenAI Agents SDK:

    <CodeGroup>
      ```bash Python  
      pip install composio_openai_agents openai-agents
      ```

      ```bash TypeScript
      pnpm install @composio/core @composio/openai-agents @openai/agents
      ```
    </CodeGroup>

    Get your Composio API key from [settings](https://platform.composio.dev/?next_page=/settings) and set it as an environment variable:

    ```bash
    export COMPOSIO_API_KEY="your-api-key"
    ```
  </Step>

  <Step title="Create Tool Router session">
    Initialize Composio and create a session for your user:

    <Tip icon="info">
      **Authentication is handled automatically**

      Tool Router provides auth URLs when needed. For production, consider [pre-configuring authentication](/docs/authenticating-tools).
    </Tip>

    <CodeGroup>
      ```python Python title="Python" maxLines=40 
      import asyncio
      import os
      from composio import Composio
      from composio_openai_agents import OpenAIAgentsProvider
      from agents import Agent, Runner, HostedMCPTool

      async def main() -> None:
      # Initialize Composio and create Tool Router session
      composio = Composio(
          api_key=os.getenv("COMPOSIO_API_KEY"),  # Uses env var by default
          provider=OpenAIAgentsProvider()
      )
      session = composio.experimental.tool_router.create_session(
          user_id="user@example.com",
          toolkits=["gmail", "github"]  # Optional: Limit available toolkits
      )
      ```

      ```typescript TypeScript title="TypeScript" maxLines=40 
      import { Composio } from '@composio/core';
      import { OpenAIAgentsProvider } from '@composio/openai-agents';
      import { Agent, hostedMcpTool, run } from '@openai/agents';

      async function main() {
      // Initialize Composio with OpenAI Agents Provider
      const composio = new Composio({
      apiKey: process.env.COMPOSIO_API_KEY,
      provider: new OpenAIAgentsProvider()
      });

      // Create a Tool Router session for your user
      const session = await composio.experimental.toolRouter.createSession(
      'user@example.com',
      {
        toolkits: ['gmail', 'github'] // Optional: Limit available toolkits
      }
      ```
    </CodeGroup>

    This generates a secure MCP endpoint URL that your AI agent will use to access Tool Router.
  </Step>

  <Step title="Set up your agent">
    Configure an OpenAI agent with the Tool Router MCP endpoint:

    <CodeGroup>
      ```python Python title="Python" maxLines=40 

      # Set up OpenAI agent with Tool Router MCP endpoint
      agent = Agent(
          name="Assistant",
          instructions="You are a helpful assistant that can access Gmail and GitHub. "
                      "Help users fetch emails, create issues, manage pull requests, and more.",
          tools=[
              HostedMCPTool(
                  tool_config={
                      "type": "mcp",
                      "server_label": "tool_router",
                      "server_url": session['url'],
                      "require_approval": "never",
                  }
              )
          ],
      )
      ```

      ```typescript TypeScript title="TypeScript" maxLines=40 
      // Create an agent with Tool Router MCP endpoint
      const agent = new Agent({
      name: 'Assistant',
      instructions: 'You are a helpful assistant that can access Gmail and GitHub. Help users fetch emails, create issues, manage pull requests, and more.',
      tools: [
        hostedMcpTool({
          serverLabel: 'tool_router',
          serverUrl: session.url,
        }),
      ],
      });
      ```
    </CodeGroup>
  </Step>

  <Step title="Run your agent">
    Execute the agent with a task:

    <CodeGroup>
      ```python Python title="Python" maxLines=40 

      # Execute the agent
      result = await Runner.run(
          agent, 
          "Fetch the contributors to composiohq/composio github repository and email the list to user@example.com"
      )
      print(result.final_output)

      asyncio.run(main())
      ```

      ```typescript TypeScript title="TypeScript" maxLines=40 
      // Execute the agent
      const result = await run(
      agent,
      'Fetch the contributors to composiohq/composio github repository and email the list to user@example.com'
      );

      console.log(result.finalOutput);
      }

      main();
      ```
    </CodeGroup>
  </Step>
</Steps>

### Visualizing Tool Router in MCP Inspector

You can inspect the session URL in any MCP client. Here's what it looks like in the MCP Inspector:

<Frame>
  <img src="file:3de014ac-19c0-4cba-9513-8a013fa4980e" alt="Tool Router Inspector" />
</Frame>

## How Tool Router works

The Tool Router executes a three-phase workflow:

**1. Discovery**\
Searches across all available tools to find ones matching your task. Returns relevant toolkits with their descriptions, schemas, and connection status.

**2. Authentication**\
Checks if the user has an active connection to the required toolkit. If not, creates an auth config and returns a connection URL using [Auth Link](/docs/authenticating-tools#hosted-authentication-connect-link). The user completes authentication through this link.

**3. Execution**\
Loads authenticated tools into context and executes them. Supports parallel execution across multiple tools for efficiency.

<Tip icon="info">
  **What are sessions?**

  Sessions are designed for security. Each presigned URL contains user authentication credentials and should never be stored long-term or exposed to the client. Generate a new URL for each conversation.
</Tip>

## Works with any MCP client

The session URL you created is a standard MCP endpoint. Use it with any framework that supports MCP:

<Info>
  Tool Router uses Streamable HTTP transport for MCP communication. Make sure your MCP client supports HTTP transport (most do).
</Info>

<CardGroup cols={2}>
  <Card title="Vercel AI SDK" icon={<img src="file:1c920887-5362-45ce-b716-2b77034e9fb2" width="24" height="24" />} href="https://ai-sdk.dev/cookbook/next/mcp-tools#mcp-tools">
    Use experimental\_createMCPClient with StreamableHTTPClientTransport to integrate with Next.js apps
  </Card>

  <Card title="Claude" icon={<img src="file:c6c1022a-658e-4551-8434-54c6dff3ec40" width="24" height="24" />} href="https://docs.claude.com/en/docs/agents-and-tools/remote-mcp-servers">
    Connect remote MCP servers through Anthropic's MCP connector API
  </Card>

  <Card title="LangChain" icon={<img src="file:f164433c-57ea-4bb6-b7f3-1ca7a05c83da" width="24" height="24" />} href="https://docs.langchain.com/oss/python/langchain/mcp">
    Load Tool Router tools using langchain\_mcp\_adapters for Python workflows
  </Card>
</CardGroup>

<Note>
  The necessary scaffolding will be integrated into existing provider abstractions before Tool Router is generally available.
</Note>

## Available meta tools

The router exposes six meta tools through MCP. These tools orchestrate the complete workflow from discovery to execution:

<AccordionGroup>
  <Accordion title="COMPOSIO_SEARCH_TOOLS">
    Discovers tools across 500+ integrated apps based on task description.

    Call this first in any workflow. Returns toolkits and tools with slugs, descriptions, input schemas, connection status, and related tools. Includes memory of previous interactions to improve future searches.
  </Accordion>

  <Accordion title="COMPOSIO_CREATE_PLAN">
    Generates step-by-step execution plans for any workflow.

    Call after `COMPOSIO_SEARCH_TOOLS`. Outputs structured plans with workflow steps, complexity assessment, decision trees for conditional logic, failure handling strategies, and output format specifications.
  </Accordion>

  <Accordion title="COMPOSIO_MANAGE_CONNECTIONS">
    Creates and manages connections to external apps.

    Call when `COMPOSIO_SEARCH_TOOLS` finds no active connection. Supports OAuth (default and custom), API keys, bearer tokens, and basic auth. Returns OAuth redirect URLs when needed and handles connection refresh.
  </Accordion>

  <Accordion title="COMPOSIO_MULTI_EXECUTE_TOOL">
    Executes up to 20 tools in parallel across different apps.

    Primary execution tool for running discovered tools. Returns structured outputs with automatic error handling and retry logic.
  </Accordion>

  <Accordion title="COMPOSIO_REMOTE_WORKBENCH">
    Persistent Python sandbox for processing large responses and bulk operations.

    Use for processing remote file data or scripting bulk executions. Provides a Jupyter notebook environment with pre-loaded helpers (run\_composio\_tool, invoke\_llm, web\_search). State persists across executions with a 4-minute timeout.
  </Accordion>

  <Accordion title="COMPOSIO_REMOTE_BASH_TOOL">
    Executes bash commands in a remote sandbox.

    Use for processing large responses saved to remote storage and file system operations. Runs from /home/user with access to shell tools (jq, awk, sed, grep). Default timeout is 300 seconds.
  </Accordion>
</AccordionGroup>

## Customization

### Restricting toolkits

Control which toolkits are available by specifying them during session creation. This limits which apps your users can access.

<CodeGroup>
  ```python
  session = composio.experimental.tool_router.create_session(
      user_id="user@example.com",
      toolkits=["github", "slack", "gmail"]
  )
  ```

  ```typescript
  const session = await composio.experimental.toolRouter.createSession(
    "user@example.com", 
    {
      toolkits: ["github", "slack", "gmail"]
    }
  );
  ```
</CodeGroup>

### Manual connection management

For advanced use cases, you can manually manage connections:

<CodeGroup>
  ```python
  session = composio.experimental.tool_router.create_session(
      user_id="user@example.com",
      toolkits=[{"toolkit": "gmail", "auth_config_id": "ac_nnn"}],
      manually_manage_connections=True
  )
  ```

  ```typescript
  const session = await composio.experimental.toolRouter.createSession(
    "user@example.com",
    {
      toolkits: [{ toolkit: 'gmail', authConfigId: 'ac_nnn' }],
      manuallyManageConnections: true
    }
  );
  ```
</CodeGroup>

When you pass the auth config ID, you can use regular Composio functions to connect accounts and check authentication status.

## Feedback

This is still very experimental and work in progress, and you can expect the contracts to change and improve as we iterate on this. That said, we would love to hear your feedback on this.

Give us feedback on this GitHub discussion [here](https://github.com/ComposioHQ/composio/discussions/2011).


# Debugging Info

> Share your debugging info with Composio team for faster issue resolution

Your debugging info is tied to your project and it helps us trace what happened and debug the issue faster.

## Finding Your Debugging Info

Navigate to your project settings to find your debugging information:

<Frame>
  <img src="file:ef41dfff-d732-4061-85ca-300638a55cd3" alt="Project Settings Debugging Info" />
</Frame>

<Frame>
  <img src="file:7af696bb-b1e9-4382-bcb1-2df005780426" alt="Debugging Info Location" />
</Frame>

## What to Share

When reaching out for support, share these identifiers:

```
@project_id: pr_xxxxxxxxxxxxx
@org_id: ok_xxxxxxxxxxxxx
@org_member_email: your-email@example.com
```

The identifiers with `pr_` (project) and `ok_` (organization) prefixes let us quickly check your logs inside our internal tracing tools, helping us resolve issues faster.

## Getting Help

<CardGroup cols={2}>
  <Card title="Join Discord" icon="fa-brands fa-discord" href="https://discord.gg/composio">
    Get basic support from the community and Composio team
  </Card>

  <Card title="GitHub Discussions" icon="fa-brands fa-github" href="https://github.com/ComposioHQ/composio/discussions">
    Request new tools and share feedback
  </Card>

  <Card title="File an Issue" icon="fa-solid fa-bug" href="https://github.com/ComposioHQ/composio/issues">
    Report SDK issues and bugs
  </Card>

  <Card title="Contact Support" icon="fa-solid fa-envelope" href="mailto:support@composio.dev">
    Reach out for dedicated support channels on Growth and Enterprise plans
  </Card>
</CardGroup>


# Our next generation SDKs

> Learn more about Composio's next generation SDKs and how to migrate

In the last few months, we have experienced very rapid growth in usage of our platform. As such, our team has been working hard to radically improve the performance and developer experience of our platform.

A lot of these changes have happened in the background, but we are excited to finally share our new SDKs with you that complement our new infra.

The new API features improved usability, enhanced stability, and better scalability. The SDKs built on top of it simplify the developer experience, making it easier than ever to build useful agents.

## What's new?

A lot of the changes are on the infra side, but from the SDK point of view, here is what you can expect:

* Faster and more reliable tool execution
* A simpler but more opinionated SDK
* Much more intuitive and consistent naming conventions
* A vastly improved TypeScript SDK that is meaningfully more type-safe and has full feature parity with the Python SDK

There aren't too many new flashy features here (yet) mainly because we wanted to get the bones right — but we feel we have a solid foundation to ship incredible new experiences on top very quickly.

## State of the new SDK and what is happening with the old SDKs?

Currently, the new SDKs are in a preview release. These new SDKs come almost fully formed, we do not expect many breaking changes to them but are releasing them in a preview state to get feedback and make necessary changes before locking them in.

As we lock the new SDKs in place, we will deprecate support for the old SDKs. They will continue to work for the foreseeable future but are no longer actively maintained. We will continue to push security updates and fix any critical bugs but will not support any new functionality in them.

We urge you to upgrade to the new SDKs as soon as possible.

## Nomenclature

We have updated several key terms in the SDK and API to improve clarity and consistency. The following table summarizes these changes:

| Previous Term | Current Term       | Definition                                                                                                                           |
| ------------- | ------------------ | ------------------------------------------------------------------------------------------------------------------------------------ |
| Actions       | Tools              | Individual operations or capabilities that can be performed by an LLM agent                                                          |
| Apps          | Toolkits           | A collection of tools grouped under a single application                                                                             |
| Integration   | Auth Config        | Configuration containing developer credentials and application-level settings such as scopes and API endpoints. Scoped to a toolkit. |
| Connection    | Connected accounts | User-linked accounts associated with a toolkit                                                                                       |
| Entity ID     | User ID            | The identifier of the user performing the action (UUID or email)                                                                     |
| Trigger       | Trigger            | An event that can be subscribed to                                                                                                   |
| Toolsets      | Providers          | LLM or agent framework that can be used with Composio to create agents                                                               |

## Switch to nano IDs from UUIDs

We have transitioned from UUIDs to nano IDs throughout the platform for the following reasons:

* **Improved readability**: UUIDs are lengthy and difficult to read
* **Better usability**: Easier to copy with a single double-click
* **Better organization**: Nano IDs allow us to distinguish between different resource types through prefixes

| Feature           | Nano ID Prefix | Example           |
| ----------------- | -------------- | ----------------- |
| Connected Account | `ca_`          | `ca_8x9w2l3k5m`   |
| Auth Config       | `ac_`          | `ac_1234567890`   |
| Trigger           | `ti_`          | `ti_So9EQf8XnAcy` |

> **Note:** Nano IDs are short, unique, and prefixed to indicate the resource type.

## SDK Changes

Upgrade to the latest SDK version using the appropriate package manager:

<CodeGroup>
  ```python Python
  pip install -U composio
  ```

  ```typescript TypeScript
  npm install @composio/core
  ```
</CodeGroup>

Both SDKs now implement proper namespacing for each concept.

### User ID scoping

The concept of `entity_id` has been expanded and renamed to `user_id`.

All operations are now scoped to a user ID, including:

* Fetching tools
* Initiating connections
* Executing tools
* Managing triggers

This change provides explicit specification of the user for whom the action is being performed. When a user may have multiple accounts (such as work and personal Gmail connections), you can use the more specific connected account ID.

### Replacing ToolSets with [Providers](/docs/providers)

We have deprecated "toolsets" in favor of "providers". This change allows Composio to provide deeper standardization for tool implementation across different frameworks.

Previously, you needed to import and use a framework-specific `ComposioToolSet` class:

<CodeGroup>
  ```python Python title="Python (previous)" maxLines=40 
  from composio_openai import ComposioToolSet, Action, App
  from openai import OpenAI

  ```

  ```typescript TypeScript title="TypeScript (previous)" maxLines=40 
  import { OpenAIToolSet } from 'composio-core';

  const toolset = new OpenAIToolSet();
  ```
</CodeGroup>

The SDK structure is now framework-agnostic and includes the OpenAI provider out of the box:

<CodeGroup>
  ```python Python title="Python (current)" maxLines=40 
  from composio import Composio
  # from composio_langchain import LangchainProvider

  composio = Composio()
  # composio = Composio(provider=LangchainProvider())

  tools = composio.tools.get(
      user_id="0001",
      tools=["LINEAR_CREATE_LINEAR_ISSUE", "GITHUB_CREATE_COMMIT"]
  )
  # tools returned is formatted for the provider. by default, OpenAI.

  ```

  ```typescript TypeScript title="TypeScript (current)" maxLines=40 
  import { Composio } from '@composio/core';
  // import { VercelProvider } from '@composio/vercel';

  const composio = new Composio({
    // provider: new VercelProvider(),
  });
  // Can specify other providers too, like OpenAI, Anthropic, Vercel AI SDK.

  const tools = await composio.tools.get('user@example.com', {
    tools: ['LINEAR_CREATE_LINEAR_ISSUE', 'GITHUB_CREATE_COMMIT'],
  });
  // tools returned is formatted for the provider. by default, OpenAI.
  ```
</CodeGroup>

You can now use the same tools across any framework with our unified interface, or create custom toolsets for frameworks we don't yet support.

Read more about [providers in our documentation](/docs/providers) and explore the [complete list of available providers](/providers/openai).

### Fetching and filtering tools

Previously, you could filter tools by:

* Apps
* Action names (tool names)
* Tags

You could also specify an `important` flag to retrieve the most important tools:

<CodeGroup>
  ```python Python title="Python (previous)" maxLines=40 
  from composio_openai import ComposioToolSet, Action, App
  from openai import OpenAI

  toolset = ComposioToolSet()
  client = OpenAI()

  tools = toolset.get_tools(
      actions=[Action.GITHUB_GET_THE_AUTHENTICATED_USER], check_connected_accounts=True
  )

  tools = toolset.get_tools(apps=[App.GITHUB, App.LINEAR, App.SLACK], check_connected_accounts=True)
  ```

  ```typescript TypeScript title="TypeScript (previous)" maxLines=40 
  import { OpenAIToolSet } from 'composio-core';

  const toolset = new OpenAIToolSet();

  const tools_1 = await toolset.getTools({ apps: ['GITHUB'] });
  const tools_2 = await toolset.getTools({
    actions: ['GITHUB_GET_THE_AUTHENTICATED_USER', 'LINEAR_CREATE_LINEAR_ISSUE'],
  });

  ```
</CodeGroup>

You can now filter tools by:

* Toolkits
* Tool slugs
* Limit parameter
* Search query

The `important` flag has been removed. Instead, tools are returned in order of importance by default:

<Note>
  Since 

  `user_id`

   is now explicitly required, the 

  `check_connected_accounts`

   flag is no longer necessary.
</Note>

<CodeGroup>
  ```python Python title="Python (current)" maxLines=40 
  from composio import Composio

  composio = Composio()

  user_id = "user@acme.org"

  tools_1 = composio.tools.get(user_id=user_id, toolkits=["GITHUB", "LINEAR"])

  tools_2 = composio.tools.get(user_id=user_id, toolkits=["SLACK"], limit=5)  # Default limit=20

  tools_3 = composio.tools.get(
      user_id=user_id,
      tools=["GITHUB_CREATE_AN_ISSUE", "GITHUB_CREATE_AN_ISSUE_COMMENT", "GITHUB_CREATE_A_COMMIT"],
  )

  tools_4 = composio.tools.get(user_id="john", search="hackernews posts")

  ```

  ```typescript TypeScript title="TypeScript (current)" maxLines=40 
  import { Composio } from '@composio/core';

  const userId = 'user@acme.org';

  const composio = new Composio();

  const tools_1 = await composio.tools.get(userId, {
    toolkits: ['GITHUB', 'LINEAR'],
  });

  const tools_2 = await composio.tools.get(userId, {
    toolkits: ['GITHUB'],
    limit: 5, // Default limit=20
  });

  const tools_3 = await composio.tools.get(userId, {
    tools: ['GITHUB_CREATE_AN_ISSUE', 'GITHUB_CREATE_AN_ISSUE_COMMENT', 'GITHUB_CREATE_A_COMMIT'],
  });

  const tools_4 = await composio.tools.get(userId, {
    search: 'hackernews posts',
  });

  ```
</CodeGroup>

### Fetching raw tool data

To examine the raw schema definition of a tool for understanding input/output parameters or building custom logic around tool definitions, use the following methods:

<CodeGroup>
  ```python Python title="Python (current)" maxLines=40 
  from composio import Composio

  composio = Composio()

  tool = composio.tools.get_raw_composio_tool_by_slug("HACKERNEWS_GET_LATEST_POSTS")

  print(tool.model_dump_json())

  ```

  ```typescript TypeScript title="TypeScript (current)" maxLines=40 
  import { Composio } from '@composio/core';

  const composio = new Composio();

  const tool = await composio.tools.getRawComposioToolBySlug('GITHUB_GET_OCTOCAT');

  console.log(JSON.stringify(tool, null, 2));

  ```
</CodeGroup>

### Executing tools

Tool execution remains largely unchanged, with `user_id` now explicitly required.

For agentic frameworks, the tool object returned from `tools.get` is now the respective framework's native tool object. Tool call execution is handled by the agentic framework itself.

<Note>
  For non-agentic frameworks, Composio provides a helper function to execute tool calls.
</Note>

<CodeGroup>
  ```python Python {16} title="Python v3" maxLines=40 
  from composio import Composio
  from openai import OpenAI

  openai_client = OpenAI()
  composio = Composio()

  tools = composio.tools.get(user_id="user@acme.com", tools=["GITHUB_GET_THE_ZEN_OF_GITHUB"])
  response = openai_client.chat.completions.create(
      model="gpt-4.1",
      messages=[{"role": "user", "content": "gimme some zen."}],
      tools=tools,
  )

  result = composio.provider.handle_tool_calls(user_id="user@acme.com", response=response)
  print(result)

  ```

  ```typescript TypeScript {27} title="TypeScript v3" maxLines=40 
  import { Composio } from '@composio/core';
  import { AnthropicProvider } from '@composio/anthropic';
  import Anthropic from '@anthropic-ai/sdk';

  const anthropic = new Anthropic();
  const composio = new Composio({
    provider: new AnthropicProvider(),
  });

  const userId = 'user@example.com';
  const tools = await composio.tools.get(userId, {
    toolkits: ['GMAIL'],
  });

  const msg = await anthropic.messages.create({
    model: 'claude-3-7-sonnet-latest',
    tools: tools,
    messages: [
      {
        role: 'user',
        content: "Say hi to 'soham@composio.dev'",
      },
    ],
    max_tokens: 1024,
  });

  const result = await composio.provider.handleToolCalls(userId, msg);
  console.log('✅ Tool results:', result);

  ```
</CodeGroup>

For more information on executing tools for different frameworks, see [Replacing ToolSets with Providers](#replacing-toolsets-with-providers).

### Tool Modifiers (formerly Tool Processors)

Tool processors have been renamed to *tool modifiers* and now provide an improved developer experience. The implementation is now available in TypeScript too! (previously Python-only).

```python Python title="Python (previous)" maxLines=40 
from composio_openai import ComposioToolSet, Action

toolset = ComposioToolSet()


def my_schema_processor(schema: dict) -> dict: ...
def my_preprocessor(inputs: dict) -> dict: ...
def my_postprocessor(result: dict) -> dict: ...


# Get tools with the modified schema
processed_tools = toolset.get_tools(
    actions=[Action.GMAIL_SEND_EMAIL],
    processors={
        # Applied BEFORE the LLM sees the schema
        "schema": {Action.SOME_ACTION: my_schema_processor},
        # Applied BEFORE the tool executes
        "pre": {Action.SOME_ACTION: my_preprocessor},
        # Applied AFTER the tool executes, BEFORE the result is returned
        "post": {Action.SOME_ACTION: my_postprocessor},
    },
)
```

| Previous           | Current                  |
| ------------------ | ------------------------ |
| `pre` processor    | `beforeExecute` modifier |
| `post` processor   | `afterExecute` modifier  |
| `schema` processor | `schema` modifier        |

The modifiers now leverage language-specific features to provide a more natural developer experience.

While tool processors could previously be applied during SDK initialization, tool fetching, and tool execution, we have restructured them as follows:

* **Chat Completion providers**: Modifiers are specified and applied during tool execution
* **Agentic frameworks**: Modifiers are specified and applied during tool fetching

#### [Schema Modifiers](/docs/modifying-tool-schemas)

The following example demonstrates schema modifier usage, applicable across all providers:

<CodeGroup>
  ```python Python (current)
  from composio import Composio, schema_modifier
  from composio.types import Tool

  user_id = "your@email.com"

  @schema_modifier(tools=["HACKERNEWS_GET_LATEST_POSTS"])
  def modify_schema(
      tool: str,
      toolkit: str,
      schema: Tool,
  ) -> Tool:
      _ = schema.input_parameters["properties"].pop("page", None)
      schema.input_parameters["required"] = ["size"]
      return schema

  tools = composio.tools.get(
      user_id=user_id,
      tools=["HACKERNEWS_GET_LATEST_POSTS", "HACKERNEWS_GET_USER"],
      modifiers=[
          modify_schema,
      ]
  )
  ```

  ```typescript TypeScript title="TypeScript (current)" maxLines=40 
  import { Composio } from '@composio/core';
  import { OpenAI } from 'openai';

  const userId = 'your@email.com';
  const composio = new Composio();

  // Schema modifier to delete the `page` argument from the `HACKERNEWS_GET_LATEST_POSTS` tool
  const tools = await composio.tools.get(
    userId,
    {
      tools: ['HACKERNEWS_GET_LATEST_POSTS', 'HACKERNEWS_GET_USER'],
    },
    {
      modifySchema: ({ toolSlug, toolkitSlug, schema }) => {
        if (toolSlug === 'HACKERNEWS_GET_LATEST_POSTS') {
          const { inputParameters } = schema;
          if (inputParameters?.properties) {
            delete inputParameters.properties['page'];
          }
          inputParameters.required = ['size'];
        }
        return schema;
      },
    }
  );

  ```
</CodeGroup>

#### [Before Modifiers](/docs/modifying-tool-inputs)

The following example shows creating and using a before modifier for a Chat Completion provider. For agentic frameworks, view the [complete before modifier documentation](/docs/modifying-tool-inputs):

<CodeGroup>
  ```python Python (current)
  @before_execute(tools=["HACKERNEWS_GET_LATEST_POSTS"])
  def before_execute_modifier(
      tool: str,
      toolkit: str,
      params: ToolExecuteParams,
  ) -> ToolExecuteParams:
      params["arguments"]["size"] = 1
      return params


  # Get tools
  tools = composio.tools.get(user_id=user_id, slug="HACKERNEWS_GET_LATEST_POSTS")
  ```

  ```typescript TypeScript title="TypeScript (current)" maxLines=40 
    const result_1 = await composio.tools.execute(
      'HACKERNEWS_GET_LATEST_POSTS',
      {
        userId,
        arguments: JSON.parse(toolArgs),
      },
      {
        beforeExecute: ({ toolSlug, toolkitSlug, params }) => {
          if (toolSlug === 'HACKERNEWS_GET_LATEST_POSTS') {
            params.arguments.size = 1;
          }
          console.log(params);
          return params;
        },
      }
    );
  ```
</CodeGroup>

#### [After Modifiers](/docs/modifying-tool-outputs)

The following example shows creating and using an after modifier for a Chat Completion provider. For agentic frameworks, view the [complete after modifier documentation](/docs/modifying-tool-outputs):

<CodeGroup>
  ```python Python (current)
  @after_execute(tools=["HACKERNEWS_GET_USER"])
  def after_execute_modifier(
      tool: str,
      toolkit: str,
      response: ToolExecutionResponse,
  ) -> ToolExecutionResponse:
      return {
          **response,
          "data": {
              "karma": response["data"]["karma"],
          },
      }

  tools = composio.tools.get(user_id=user_id, slug="HACKERNEWS_GET_USER")
  ```

  ```typescript TypeScript title="TypeScript (current)" maxLines=40 
    const result_2 = await composio.tools.execute(
      'HACKERNEWS_GET_USER',
      {
        userId,
        arguments: JSON.parse(toolArgs),
      },
      {
        afterExecute: ({ toolSlug, toolkitSlug, result }) => {
          if (toolSlug === 'HACKERNEWS_GET_USER') {
            const { data } = result;
            const { karma } = data.response_data as { karma: number };
            return {
              ...result,
              data: { karma },
            };
          }
          return result;
        },
      }
    );

    console.log(JSON.stringify(result, null, 2));
  ```
</CodeGroup>

### Custom Tools

The SDK continues to support custom tools. [Creating tools from your methods](/docs/custom-tools#creating-a-custom-tool) remains possible. We recommend reviewing the [detailed custom tools documentation](/docs/custom-tools#creating-a-custom-tool) for more information.

Due to changes in the SDK architecture, creating custom tools that use Composio's managed authentication has been modified. In the previous SDK, you could create a custom tool as follows:

<CodeGroup>
  ```python Python {14-17} title="Python (previous)" maxLines=40 
  # Python Example using execute_request
  from composio import action, ComposioToolSet
  import typing as t

  toolset = ComposioToolSet()

  @action(toolname="github") # Associate with GitHub app for auth
  def get_github_repo_topics(
      owner: t.Annotated[str, "Repository owner username"],
      repo: t.Annotated[str, "Repository name"],
      execute_request: t.Callable # Injected by Composio
  ) -> dict:
      """Gets the topics associated with a specific GitHub repository."""
      response_data = execute_request(
          endpoint=f"/repos/{owner}/{repo}/topics", # API path relative to base URL
          method="GET"
      )
      if isinstance(response_data, dict):
          return {"topics": response_data.get("names", [])}
  ```

  ```typescript TypeScript {16-20} title="TypeScript (previous)" maxLines=40 
  import { OpenAIToolSet, type ActionExecutionResDto } from "composio-core";
  import { z } from "zod";

  const toolset = new OpenAIToolSet();

  await toolset.createAction({
      actionName: "get_github_repo_topics",
      toolName: "github",
      description: "Gets the topics associated with a specific GitHub repository.",
      inputParams: z.object({
          owner: z.string().describe("Repository owner username"),
          repo: z.string().describe("Repository name"),
      }),
      callback: async (inputParams, _authCredentials, executeRequest): Promise<ActionExecutionResDto> => {
           const { owner, repo } = inputParams as { owner: string, repo: string };
           const response = await executeRequest({
               endpoint: `/repos/${owner}/${repo}/topics`,
               method: "GET",
               parameters: [],
           });

           const topics = (response as any)?.names ?? [];
           return { successful: true, data: { topics: topics } };
      }
  });
  ```
</CodeGroup>

The *execute tool request* method handles injection of the appropriate base URL and authentication credentials for the tool:

<CodeGroup>
  ```python Python {22} title="Python (current)" maxLines=40 
  from pydantic import BaseModel, Field
  from composio import Composio
  from composio.core.models.custom_tools import ExecuteRequestFn


  composio = Composio()

  class GetIssueInfoInput(BaseModel):
      issue_number: int = Field(
          ...,
          description="The number of the issue to get information about",
      )

  # function name will be used as slug
  @composio.tools.custom_tool(toolkit="github")
  def get_issue_info(
      request: GetIssueInfoInput,
      execute_request: ExecuteRequestFn,
      auth_credentials: dict,
  ) -> dict:
      """Get information about a GitHub issue."""
      response = execute_request(
          endpoint=f"/repos/composiohq/composio/issues/{request.issue_number}",
          method="GET",
          parameters=[
              {
                  "name": "Accept",
                  "value": "application/vnd.github.v3+json",
                  "type": "header",
              },
              {
                  "name": "Authorization",
                  "value": f"Bearer {auth_credentials['access_token']}",
                  "type": "header",
              },
          ],
      )
      return {"data": response.data}

  ```

  ```typescript TypeScript {17} title="TypeScript (current)" maxLines=40 
  import { Composio } from "@composio/core";
  import z from "zod";

  const composio = new Composio();

  const tool = await composio.tools.createCustomTool({
      slug: 'GITHUB_STAR_COMPOSIOHQ_REPOSITORY',
      name: 'Github star composio repositories',
      toolkitSlug: 'github',
      description: 'Star any specificied repo of `composiohq` user',
      inputParams: z.object({
        repository: z.string().describe('The repository to star'),
        page: z.number().optional().describe('Pagination page number'),
        customHeader: z.string().optional().describe('Custom header'),
      }),
      execute: async (input, connectionConfig, executeToolRequest) => {
        const result = await executeToolRequest({
          endpoint: `/user/starred/composiohq/${input.repository}`,
          method: 'PUT',
          body: {},
          parameters: [
            {
              name: 'page',
              value: input.page?.toString() || '1',
              in: 'query',
            },
            {
              name: 'x-custom-header',
              value: input.customHeader || 'default-value',
              in: 'header',
            },
          ],
        });
        return result;
      },
    });
    
  ```
</CodeGroup>

For more information, including executing custom tools and defining custom headers and query parameters, refer to the [Custom Tools](/docs/custom-tools) documentation.

### Auth configs (formerly integrations)

Integrations are now called *auth configs*. While the terminology has changed, the underlying concept remains the same.

Auth configs store the configuration required for authentication with a given toolkit, including OAuth developer credentials, configurable base URLs, and scopes.

Auth configs now use nano IDs instead of UUIDs:

| Previous (UUID) Example                | Current (Nano ID) Example |
| :------------------------------------- | :------------------------ |
| `b7a9c1e2-3f4d-4a6b-8c2e-1d2f3a4b5c6d` | `ac_8x9w2l3k5m`           |

We recommend storing auth config nano IDs in your database for connecting users to the appropriate auth configuration.

For most use cases, you will create auth configs through the dashboard, and this process remains unchanged. Read more about [creating auth configs](/docs/authenticating-tools#creating-an-auth-config) and [customizing auth configs](/docs/custom-auth-configs).

Creating auth configs programmatically in the previous SDK:

<CodeGroup>
  ```python Python title="Python (previous)" maxLines=40 
  from composio_openai import App, ComposioToolSet

  toolset = ComposioToolSet()

  integration = toolset.create_integration(
      app=App.GITHUB,
      auth_mode="OAUTH2",
      use_composio_oauth_app=True,
      # For use_composio_oauth_app=False, you can provide your own OAuth app credentials here
      # auth_config={
      #     "client_id": "123456",
      #     "client_secret": "123456"
      # }

  )
  ```

  ```typescript TypeScript title="TypeScript (previous)" maxLines=40 
  import { OpenAIToolSet } from "composio-core";

  const composioToolset = new OpenAIToolSet();

  const integration = await composioToolset.integrations.create({
      name: "gmail_integration",
      appUniqueKey: "gmail",
      forceNewIntegration: true,
      useComposioAuth: false,
      // For useComposioAuth: false, you can provide your own OAuth app credentials here
      // authScheme: "OAUTH2",
      // authConfig: {
      //     clientId: "123456",
      //     clientSecret: "123456"
      // }
  ```
</CodeGroup>

Creating auth configs programmatically in the current SDK:

<CodeGroup>
  ```python Python title="Python (current)" maxLines=40 
  from composio import Composio

  composio = Composio()

  # Use composio managed auth
  auth_config = composio.auth_configs.create(
      toolkit="notion",
      options={
          "type": "use_composio_managed_auth",
          # "type": "use_custom_auth",
          # "auth_scheme": "OAUTH2",
          # "credentials": {
          #     "client_id": "1234567890",
          #     "client_secret": "1234567890",
          #     "oauth_redirect_uri": "https://backend.composio.dev/api/v3/toolkits/auth/callback",
  ```

  ```typescript TypeScript title="TypeScript (current)" maxLines=40 
  import { Composio } from '@composio/core';

  const composio = new Composio();

  const authConfig = await composio.authConfigs.create('LINEAR', {
    name: 'Linear',
    type: 'use_composio_managed_auth',
    //   type: "use_custom_auth",
    //   credentials: {
    //     client_id: "1234567890",
    //     client_secret: "1234567890",
    //     oauth_redirect_uri: "https://backend.composio.dev/api/v3/toolkits/auth/callback",
    // },
  });

  ```
</CodeGroup>

For using custom authentication credentials, refer to the [Programmatic Auth Configs](/docs/programmatic-auth-configs) documentation.

<Note>
  The callback URL for creating custom OAuth configs is now 

  `https://backend.composio.dev/api/v3/toolkits/auth/callback`

  . The previous URL was 

  `https://backend.composio.dev/api/v1/auth-apps/add`

  .
</Note>

### Connected accounts / User IDs

The primary change in connected accounts and user IDs is that user IDs are now a more prominent concept compared to entities in previous versions.

We have simplified the process of connecting a user to a toolkit. Instead of multiple methods and parameters for initiating a connection, both the SDK and API now require only a `user_id` and `auth_config_id` to initiate a connection.

This approach is more explicit and works well with the ability for developers to have multiple auth configs for a given toolkit.

Connected accounts now use nano IDs instead of UUIDs:

| Previous (UUID) Example                | Current (Nano ID) Example |
| :------------------------------------- | :------------------------ |
| `b7a9c1e2-3f4d-4a6b-8c2e-1d2f3a4b5c6d` | `ca_8x9w2l3k5m`           |

Previously, you might have initiated a connection like this:

<CodeGroup>
  ```python Python {11-16} title="Python (previous)" maxLines=40 
  from composio_openai import ComposioToolSet

  toolset = ComposioToolSet()
  user_id = "your_user_unique_id"
  google_integration_id = "0000-0000"

  entity = toolset.get_entity(id=user_id)

  try:
      print(f"Initiating OAuth connection for entity {entity.id}...")
      connection_request = toolset.initiate_connection(
          integration_id=google_integration_id,
          entity_id=user_id,
          # Optionally add: redirect_url="https://yourapp.com/final-destination"
          # if you want user sent somewhere specific *after* Composio finishes.
      )

      # Check if a redirect URL was provided (expected for OAuth)
      if connection_request.redirectUrl:
          print(f"Received redirect URL: {connection_request.redirectUrl}")
      else:
          print("Error: Expected a redirectUrl for OAuth flow but didn't receive one.")


  except Exception as e:
      print(f"Error initiating connection: {e}")

  ```

  ```typescript TypeScript {8-13} title="TypeScript (previous)" maxLines=40 
  import { OpenAIToolSet } from "composio-core";

  const toolset = new OpenAIToolSet();
  const userId = "your_user_unique_id";
  const googleIntegrationId = "0000-0000";

  console.log(`Initiating OAuth connection for entity ${userId}...`);
  const connectionRequest = await toolset.connectedAccounts.initiate({
      integrationId: googleIntegrationId,
      entityId: userId,
      // Optionally add: redirectUri: "https://yourapp.com/final-destination"
      // if you want user sent somewhere specific *after* Composio finishes.
  });

  // Check if a redirect URL was provided (expected for OAuth)
  if (connectionRequest?.redirectUrl) {
      console.log(`Received redirect URL: ${connectionRequest.redirectUrl}`);
      // Proceed to Step 2: Redirect the user
      // Return or pass connectionRequest to the next stage
  } else {
      console.error("Error: Expected a redirectUrl for OAuth flow but didn't receive one.");
  }

  ```
</CodeGroup>

The current process for initiating a connection is as follows:

<CodeGroup>
  ```python Python {8-11} title="Python (current)" maxLines=40 
  from composio import Composio

  linear_auth_config_id = "ac_1234"
  user_id = "user@email.com"
  composio = Composio()

  # Create a new connected account
  connection_request = composio.connected_accounts.initiate(
      user_id=user_id,
      auth_config_id=linear_auth_config_id,
  )
  print(connection_request.redirect_url)

  # Wait for the connection to be established
  connected_account = connection_request.wait_for_connection()
  ```

  ```typescript TypeScript {8-11} title="TypeScript (current)" maxLines=40 
  import { Composio } from "@composio/core";

  const composio = new Composio();
  const linearAuthConfigId = "ac_1234";
  const userId = "user@email.com";

  // Initiate the OAuth connection request
  const connRequest = await composio.connectedAccounts.initiate(userId, linearAuthConfigId);

  const { redirectUrl, id } = connRequest;
  console.log(redirectUrl);

  // Wait for the connection to be established
  await connRequest.waitForConnection();

  ```
</CodeGroup>

### Triggers

Composio continues to support listening to application events using triggers through WebSockets and webhooks.

#### Creating triggers

The process for creating triggers and specifying their configuration has been redesigned for improved clarity and intuitiveness.

Some triggers require configuration, such as repository names for GitHub triggers or channel names for Slack triggers. The process usually follows the pattern of fetching the trigger type and then creating the trigger with the appropriate configuration.

<CodeGroup>
  ```python Python title="Python (current)" maxLines=40 
  from composio import Composio

  composio = Composio()

  user_id = "user@example.com"
  trigger_config = composio.triggers.get_type("GITHUB_COMMIT_EVENT")
  print(trigger_config.config)
  ### Trigger Config
  # {
  #     "properties": {
  #         "owner": {
  #             "description": "Owner of the repository",
  #             "title": "Owner",
  #             "type": "string"
  #         },
  #         "repo": {
  #             "description": "Repository name",
  #             "title": "Repo",
  #             "type": "string"
  #         }
  #     },
  #     "required": ["owner", "repo"],
  #     "title": "WebhookConfigSchema",
  #     "type": "object"

  trigger = composio.triggers.create(
      slug="GITHUB_COMMIT_EVENT",
      user_id=user_id,
      trigger_config={"repo": "composiohq", "owner": "composio"},
  )
  print(trigger)


  ```

  ```typescript TypeScript title="TypeScript (current)" maxLines=40 
  import { Composio } from '@composio/core';

  const composio = new Composio();

  const userId = 'user@acme.com';
  // Fetch the trigger details
  const triggerType = await composio.triggers.getType('GITHUB_COMMIT_EVENT');
  console.log(JSON.stringify(triggerType.config, null, 2));
  /*--- Trigger config ---
  {
    "properties": {
      "owner": {
        "description": "Owner of the repository",
        "title": "Owner",
        "type": "string"
      },
      "repo": {
        "description": "Repository name",
        "title": "Repo",
        "type": "string"
      }
    },
    "required": ["owner", "repo"],
    "title": "WebhookConfigSchema",
    "type": "object"
  }
  */

  const createResponse = await composio.triggers.create(userId, 'GITHUB_COMMIT_EVENT', {
    triggerConfig: {
      owner: 'composiohq',
      repo: 'composio',
    },
  });
  console.log(createResponse);
  ```
</CodeGroup>

#### Enabling/Disabling triggers

You can enable or disable triggers through either the SDK or the dashboard. The dashboard process remains unchanged.

Managing triggers with the SDK:

<CodeGroup>
  ```python Python maxLines=60 wordWrap
  # Disable a trigger instance 
  disabled_instance = composio.triggers.disable(trigger_id="ti_abcd123")
  print(disabled_instance) 
  ```

  ```typescript TypeScript maxLines=60 wordWrap
  await composio.triggers.disable("ti_abcd123");
  ```
</CodeGroup>

If needed, the trigger can be enabled again.

<CodeGroup>
  ```python Python maxLines=60 wordWrap
  # Enable a trigger instance
  enabled_instance = composio.triggers.enable(trigger_id="ti_abcd123")
  print(enabled_instance)
  ```

  ```typescript TypeScript maxLines=60 wordWrap
  await composio.triggers.enable("ti_abcd123");
  ```
</CodeGroup>

#### Listening to triggers

We recommend listening to triggers through webhooks. The following are example routes for Next.js and FastAPI.

For development, you can also [listen to triggers through the SDK](/docs/using-triggers#subscribing-to-triggers-using-the-sdk-for-development).

<CodeGroup>
  ```python Python title="app/route.py (FastAPI)" maxLines=40 
  from fastapi import FastAPI, Request
  from typing import Dict, Any
  import uvicorn
  import json

  app = FastAPI(title="Webhook Demo")

  @app.post("/webhook")
  async def webhook_handler(request: Request):
      # Get the raw payload
      payload = await request.json()
      
      # Log the received webhook data
      print("Received webhook payload:")
      print(json.dumps(payload, indent=2))
      
      # Return a success response
      return {"status": "success", "message": "Webhook received"}

  if __name__ == "__main__":
      uvicorn.run(app, host="0.0.0.0", port=8000)


  ```

  ```typescript TypeScript title="app/api/webhook/route.ts (Next.js)" maxLines=40 
  import type { NextApiRequest, NextApiResponse } from 'next';
  import { TriggerEvent } from '@composio/core';

  // Define type-safe payload for GitHub Star Added event
  export type GitHubStarAddedEventPayload = {
    action: "created";
    repository_id: number;
    repository_name: string;
    repository_url: string;
    starred_at: string;
    starred_by: string;
  };

  // Type-safe handler function
  function handleGitHubStarAddedEvent(event: TriggerEvent<GitHubStarAddedEventPayload>) {
    console.log(`⭐ ${event.data.repository_name} starred by ${event.data.starred_by}`);
  }

  export default async function handler(req: NextApiRequest, res: NextApiResponse) {
    if (req.method !== 'POST') {
      return res.status(405).json({ 
        status: 'error', 
        message: 'Method not allowed. Only POST requests are accepted.' 
      });
    }

    try {
      const payload = req.body;
      
      // Type-safe webhook payload processing
      if (payload.triggerSlug === 'GITHUB_STAR_ADDED_EVENT') {
        const starEvent: TriggerEvent<GitHubStarAddedEventPayload> = {
          type: payload.triggerSlug,
          timestamp: new Date().toISOString(),
          data: {
            ...payload.payload as GitHubStarAddedEventPayload,
            connection_nano_id: payload.metadata?.connectedAccount?.id || '',
            trigger_nano_id: payload.id || '',
            user_id: payload.userId || '',
          }
        };
        
        handleGitHubStarAddedEvent(starEvent);
      }
      
      res.status(200).json({ 
        status: 'success', 
        message: 'Webhook received and processed successfully'
      });
    } catch (error) {
      console.error('Error processing webhook:', error);
      res.status(500).json({ 
        status: 'error', 
        message: 'Internal server error while processing webhook' 
      });
    }
  }

  ```
</CodeGroup>

## 🚧 Coming Soon

### Local tools

Previously, the Python SDK included *[local tools](https://github.com/ComposioHQ/composio/tree/master/python/composio/tools/local)*. These were tools defined within the SDK and consisted of local shell and code-related tools such as "clipboard", "sqltool", and "shelltool".

This feature is currently in development for both Python and TypeScript SDKs, with newly created tools built for improved agent accuracy.

{/* ### Generated types

In the previous Python SDK, you could generate types for tools using the CLI:

```bash
composio apps generate-types
```

This provided app slugs and tool slugs with IntelliSense support:

```python Python (previous)
from composio_openai import ComposioToolSet, App, Action

print(App.GITHUB)
print(Action.GITHUB_CREATE_ISSUE)
``` */}

This feature is currently in development for both Python and TypeScript SDKs.

## API Endpoints

The following table lists important API endpoints that have changed. You can use this reference to quickly find the new v3 API endpoint for migration:

<Note>
  This list is not exhaustive. Please refer to the 

  [API Reference](/api-reference)

   for the complete list of endpoints.
</Note>

### Toolkits (formerly Apps)

| Previous Endpoint                                                                                                    | Current Endpoint                                                                                              |
| :------------------------------------------------------------------------------------------------------------------- | :------------------------------------------------------------------------------------------------------------ |
| [`GET /api/v1/apps`](https://docs.composio.dev/api-reference/api-reference/apps/get-apps)                            | [`GET /api/v3/toolkits`](https://docs.composio.dev/api-reference/toolkits/get-toolkits)                       |
| [`GET /api/v1/apps/list/categories`](https://docs.composio.dev/api-reference/api-reference/apps/list-app-categories) | [`GET /api/v3/toolkits/categories`](https://docs.composio.dev/api-reference/toolkits/get-toolkits-categories) |
| [`GET /api/v1/apps/{appName}`](https://docs.composio.dev/api-reference/api-reference/apps/get-app)                   | [`GET /api/v3/toolkits/{slug}`](https://docs.composio.dev/api-reference/toolkits/get-toolkits-by-slug)        |

### Tools (formerly Actions)

| Previous Endpoint                                                                                                                           | Current Endpoint                                                                                                                      |
| :------------------------------------------------------------------------------------------------------------------------------------------ | :------------------------------------------------------------------------------------------------------------------------------------ |
| [`GET /api/v2/actions`](https://docs.composio.dev/api-reference/api-reference/actions/list-actions-minimal-v-2)                             | [`GET /api/v3/tools`](https://docs.composio.dev/api-reference/tools/get-tools)                                                        |
| [`GET /api/v2/actions/list/enums`](https://docs.composio.dev/api-reference/api-reference/actions/list-action-enums)                         | [`GET /api/v3/tools/enum`](https://docs.composio.dev/api-reference/tools/get-tools-enum)                                              |
| [`GET /api/v2/actions/{actionId}`](https://docs.composio.dev/api-reference/api-reference/actions/get-action-v-2)                            | [`GET /api/v3/tools/{tool_slug}`](https://docs.composio.dev/api-reference/tools/get-tools-by-tool-slug)                               |
| [`POST /api/v2/actions/{actionId}/execute`](https://docs.composio.dev/api-reference/api-reference/actions/execute-action-v-2)               | [`POST /api/v3/tools/execute/{tool_slug}`](https://docs.composio.dev/api-reference/tools/post-tools-execute-by-tool-slug)             |
| [`POST /api/v2/actions/{actionId}/execute/get.inputs`](https://docs.composio.dev/api-reference/api-reference/actions/get-action-inputs-v-2) | [`POST /api/v3/tools/execute/{tool_slug}/input`](https://docs.composio.dev/api-reference/tools/post-tools-execute-by-tool-slug-input) |
| [`POST /api/v2/actions/proxy`](https://docs.composio.dev/api-reference/api-reference/actions/execute-action-proxy-v-2)                      | [`POST /api/v3/tools/execute/proxy`](https://docs.composio.dev/api-reference/tools/post-tools-execute-proxy)                          |

### Auth Configs (formerly Integrations/Connectors)

| Previous Endpoint                                                                                                                    | Current Endpoint                                                                                                             |
| :----------------------------------------------------------------------------------------------------------------------------------- | :--------------------------------------------------------------------------------------------------------------------------- |
| [`GET /api/v1/integrations`](https://docs.composio.dev/api-reference/api-reference/integrations/list-all-connectors)                 | [`GET /api/v3/auth_configs`](https://docs.composio.dev/api-reference/auth-configs/get-auth-configs)                          |
| [`POST /api/v1/integrations`](https://docs.composio.dev/api-reference/api-reference/integrations/create-connector)                   | [`POST /api/v3/auth_configs`](https://docs.composio.dev/api-reference/auth-configs/post-auth-configs)                        |
| [`GET /api/v1/integrations/{integrationId}`](https://docs.composio.dev/api-reference/api-reference/integrations/get-connector-info)  | [`GET /api/v3/auth_configs/{nanoid}`](https://docs.composio.dev/api-reference/auth-configs/get-auth-configs-by-nanoid)       |
| [`PATCH /api/v1/integrations/{integrationId}`](https://docs.composio.dev/api-reference/api-reference/integrations/modify-connector)  | [`PATCH /api/v3/auth_configs/{nanoid}`](https://docs.composio.dev/api-reference/auth-configs/patch-auth-configs-by-nanoid)   |
| [`DELETE /api/v1/integrations/{integrationId}`](https://docs.composio.dev/api-reference/api-reference/integrations/delete-connector) | [`DELETE /api/v3/auth_configs/{nanoid}`](https://docs.composio.dev/api-reference/auth-configs/delete-auth-configs-by-nanoid) |
| [`POST /api/v2/integrations/create`](https://docs.composio.dev/api-reference/api-reference/integrations-v-2/create-connector-v-2)    | [`POST /api/v3/auth_configs`](https://docs.composio.dev/api-reference/auth-configs/post-auth-configs)                        |

### Connected Accounts (formerly Connections)

| Previous Endpoint                                                                                                                                           | Current Endpoint                                                                                                                                            |
| :---------------------------------------------------------------------------------------------------------------------------------------------------------- | :---------------------------------------------------------------------------------------------------------------------------------------------------------- |
| [`GET /api/v1/connectedAccounts`](https://docs.composio.dev/api-reference/api-reference/connections/get-connections)                                        | [`GET /api/v3/connected_accounts`](https://docs.composio.dev/api-reference/connected-accounts/get-connected-accounts)                                       |
| [`POST /api/v1/connectedAccounts`](https://docs.composio.dev/api-reference/api-reference/connections/initiate-connection)                                   | [`POST /api/v3/connected_accounts`](https://docs.composio.dev/api-reference/connected-accounts/post-connected-accounts)                                     |
| [`POST /api/v2/connectedAccounts/initiateConnection`](https://docs.composio.dev/api-reference/api-reference/connectionsv-2/initiate-connection-v-2)         | [`POST /api/v3/connected_accounts`](https://docs.composio.dev/api-reference/connected-accounts/post-connected-accounts)                                     |
| [`GET /api/v1/connectedAccounts/{connectedAccountId}`](https://docs.composio.dev/api-reference/api-reference/connections/get-connection)                    | [`GET /api/v3/connected_accounts/{nanoid}`](https://docs.composio.dev/api-reference/connected-accounts/get-connected-accounts-by-nanoid)                    |
| [`DELETE /api/v1/connectedAccounts/{connectedAccountId}`](https://docs.composio.dev/api-reference/api-reference/connections/delete-connection)              | [`DELETE /api/v3/connected_accounts/{nanoid}`](https://docs.composio.dev/api-reference/connected-accounts/delete-connected-accounts-by-nanoid)              |
| [`POST /api/v1/connectedAccounts/{connectedAccountId}/disable`](https://docs.composio.dev/api-reference/api-reference/connections/disable-connection)       | [`PATCH /api/v3/connected_accounts/{nanoId}/status`](https://docs.composio.dev/api-reference/connected-accounts/patch-connected-accounts-by-nano-id-status) |
| [`POST /api/v1/connectedAccounts/{connectedAccountId}/enable`](https://docs.composio.dev/api-reference/api-reference/connections/enable-connection)         | [`PATCH /api/v3/connected_accounts/{nanoId}/status`](https://docs.composio.dev/api-reference/connected-accounts/patch-connected-accounts-by-nano-id-status) |
| [`POST /api/v1/connectedAccounts/{connectedAccountId}/reinitiate`](https://docs.composio.dev/api-reference/api-reference/connections/reinitiate-connection) | [`POST /api/v3/connected_accounts/{nanoid}/refresh`](https://docs.composio.dev/api-reference/connected-accounts/post-connected-accounts-by-nanoid-refresh)  |

### Triggers

| Previous Endpoint                                                                                                                                     | Current Endpoint                                                                                                                                        |
| :---------------------------------------------------------------------------------------------------------------------------------------------------- | :------------------------------------------------------------------------------------------------------------------------------------------------------ |
| [`GET /api/v1/triggers`](https://docs.composio.dev/api-reference/api-reference/triggers/list-triggers)                                                | [`GET /api/v3/triggers_types`](https://docs.composio.dev/api-reference/triggers/get-triggers-types)                                                     |
| [`GET /api/v1/triggers/list/enums`](https://docs.composio.dev/api-reference/api-reference/triggers/list-trigger-enums)                                | [`GET /api/v3/triggers_types/list/enum`](https://docs.composio.dev/api-reference/triggers/get-triggers-types-list-enum)                                 |
| [`GET /api/v2/triggers/{triggerName}`](https://docs.composio.dev/api-reference/api-reference/triggers/get-trigger-info-v-2)                           | [`GET /api/v3/triggers_types/{slug}`](https://docs.composio.dev/api-reference/triggers/get-triggers-types-by-slug)                                      |
| [`GET /api/v1/triggers/active_triggers`](https://docs.composio.dev/api-reference/api-reference/triggers/get-active-triggers)                          | [`GET /api/v3/trigger_instances/active`](https://docs.composio.dev/api-reference/triggers/get-trigger-instances-active)                                 |
| [`POST /api/v1/triggers/enable/{connectedAccountId}/{triggerName}`](https://docs.composio.dev/api-reference/api-reference/triggers/enable-trigger)    | [`POST /api/v3/trigger_instances/{slug}/upsert`](https://docs.composio.dev/api-reference/triggers/post-trigger-instances-by-slug-upsert)                |
| [`DELETE /api/v1/triggers/instance/{triggerInstanceId}`](https://docs.composio.dev/api-reference/api-reference/triggers/delete-trigger)               | [`DELETE /api/v3/trigger_instances/manage/{triggerId}`](https://docs.composio.dev/api-reference/triggers/delete-trigger-instances-manage-by-trigger-id) |
| [`PATCH /api/v1/triggers/instance/{triggerId}/status`](https://docs.composio.dev/api-reference/api-reference/triggers/switch-trigger-instance-status) | [`PATCH /api/v3/trigger_instances/manage/{triggerId}`](https://docs.composio.dev/api-reference/triggers/patch-trigger-instances-manage-by-trigger-id)   |


# Troubleshooting

> Common issues and quick links

This section is designed to help you quickly identify and resolve common issues encountered with the Composio.

Some quick links:

<Card title="Report issues" icon="fa-solid fa-bug" href="https://github.com/ComposioHQ/composio/issues/new?labels=bug">
  Found a bug? Please create a Github issue!
</Card>

<Card title="Ask AI" icon="fa-solid fa-brain" href="https://deepwiki.com/ComposioHQ/composio">
  Try to use Ask AI in the docs or deepwiki to get the fastes responses on features, types, and best practices.
</Card>

<Card title="Feature requests" icon="fa-solid fa-sparkles" href="https://github.com/ComposioHQ/composio/issues/new?labels=enhancement">
  Have an idea for improving Composio? Share your feature suggestions with us and we will prioritise your requests
</Card>

<Card title="Ask the community" icon="fa-solid fa-comments" href="https://github.com/ComposioHQ/composio/discussions">
  Join our GitHub discussions to get help from the community
</Card>

<Card title="Discord community" icon="fa-brands fa-discord" href="https://discord.com/channels/1170785031560646836/1268871288156323901">
  Post support queries on our discord channel or reachout to [support@composio.dev](mailto:support@composio.dev)
</Card>

<Card title="Migration guides" icon="fa-solid fa-book" href="/docs/migration">
  Check out our migration guides to help you upgrade to the latest version.
</Card>


# API

> Debugging and troubleshooting API issues

## Reporting API issues

When reporting API issues to support, provide the following:

* **cURL command**: Include the exact cURL to reproduce the issue
* **Request ID**: Add `x-request-id: <uuid>` header to your request and share the UUID (generate at [uuidgenerator.net](https://www.uuidgenerator.net/))
* **Error details**: Share the complete error message
* **Reproduction steps**: Include any steps needed to reproduce the issue

## Getting help

* **Email**: [support@composio.dev](mailto:support@composio.dev)
* **Discord**: [#support-form](https://discord.com/channels/1170785031560646836/1268871288156323901)


# Authentication

> Debugging and troubleshooting authentication issues

## Using Composio's default OAuth app

When using our default OAuth configuration:

* **Don't add additional scopes** - They may not be approved in our OAuth app
* Use only the pre-configured scopes provided

## Using custom OAuth apps

Ensure your OAuth app is configured correctly:

* **Redirect URL**: Must match exactly what's configured in your OAuth provider
* **Scopes**: Auth config scopes must match your OAuth app configuration
* **Credentials**: Verify client ID and secret are correct

For setup guides by toolkit: [OAuth Configuration Guides](https://composio.dev/oauth)

## Common authentication issues

* **Invalid redirect URI**: Check the callback URL matches exactly
* **Scope mismatch**: Ensure requested scopes are configured in both auth config and OAuth app
* **Expired tokens**: Try refreshing the connection
* **Rate limits**: Some providers limit authentication attempts

## Reporting authentication issues

When reporting to support, provide:

* **Error message**: Complete error details and screenshots
* **Auth config ID**: The `authConfigId` being used
* **Connected account ID**: If a connection was already created
* **OAuth provider**: Which service you're trying to connect

## Getting help

* **Email**: [support@composio.dev](mailto:support@composio.dev)
* **Discord**: [#support-form](https://discord.com/channels/1170785031560646836/1268871288156323901)


# Dashboard

> Debugging and troubleshooting dashboard issues

## Reporting dashboard issues

When reporting dashboard issues to support, provide:

* **Screenshot or recording**: Visual evidence of the issue
* **Error details**: Complete error message shown in the UI
* **Network logs**: Check browser DevTools for failing API calls and share:
  * Error message
  * Request ID (`x-request-id` header)
  * Failed endpoint URL

## Getting help

* **Email**: [support@composio.dev](mailto:support@composio.dev)
* **Discord**: [#support-form](https://discord.com/channels/1170785031560646836/1268871288156323901)


# MCP

> Debugging and troubleshooting MCP server issues

## Connected account not found error

This error occurs when MCP cannot find a valid connected account for authentication:

* **Specify an account**: Provide either `connected_account_id` or `user_id` in your MCP configuration
* **Default behavior**: Without specification, MCP uses `user_id=default`. If multiple connections exist with the same user\_id, the most recent is used
* **Verification checklist**:
  * Account status is `ACTIVE` (not deleted)
  * Account belongs to the same auth config used to create the MCP server

Learn more: [MCP Developer Guide](/docs/mcp-developers#client-applications-connect-to-the-server)

## Getting 404 errors

Verify your URL format matches one of these patterns:

* `https://mcp.composio.dev/composio/server/<UUID>/mcp`
* `https://apollo-<randomID>-composio.vercel.app/v3/mcp/<UUID>`
* `https://apollo.composio.dev/v3/mcp/<UUID>`

## Testing and debugging

If experiencing issues, test your MCP server with:

* [Postman MCP Requests](https://learning.postman.com/docs/postman-ai-developer-tools/mcp-requests/create/)
* [MCP Inspector](https://modelcontextprotocol.io/docs/tools/inspector)

This helps identify whether the issue is with your MCP client or the server.

## Reporting MCP issues

When reporting to support, provide:

* **Error message**: Complete error details
* **MCP server URL**: The exact URL you're connecting to
* **Testing results**: Whether issue reproduces in MCP Inspector/Postman or only in specific client
* **Connected account ID**: If facing connection issues
* **Reproduction steps**: Clear steps to reproduce the issue

## Getting help

* **Email**: [support@composio.dev](mailto:support@composio.dev)
* **Discord**: [#support-form](https://discord.com/channels/1170785031560646836/1268871288156323901)


# SDKs

> Debugging and troubleshooting SDK issues

## Debug network issues

Enable debug logging to see API calls and identify if issues are SDK or API related. Look for the `x-request-id` in logs to share with support.

<CodeGroup>
  ```python Python
  # Set environment variable
  COMPOSIO_LOGGING_LEVEL=debug
  ```

  ```typescript TypeScript
  // Set environment variable
  COMPOSIO_LOG_LEVEL=debug
  ```
</CodeGroup>

## Check SDK version

Ensure you're using the latest version:

<CodeGroup>
  ```bash Python
  pip install --upgrade composio
  ```

  ```bash TypeScript
  npm install @composio/core@latest
  ```
</CodeGroup>

Check current version:

* Python: [PyPI](https://pypi.org/project/composio/)
* TypeScript: [npm](https://www.npmjs.com/package/@composio/core)

## Common issues

* **Type errors or parameter confusion**: Search [DeepWiki](https://deepwiki.com/ComposioHQ/composio) or use the Ask AI assistant
* **Tool-specific issues**: Check the [specific tool's documentation](/toolkits/introduction)
* **Bug reporting**: Create a [GitHub issue](https://github.com/ComposioHQ/composio/issues/new?labels=bug) with debug logs and reproduction steps

## Getting help

* **Email**: [support@composio.dev](mailto:support@composio.dev)
* **Discord**: [#support-form](https://discord.com/channels/1170785031560646836/1268871288156323901)


# Tools & Toolkits

> Debugging and troubleshooting tool execution issues

## Tool execution failures (401/403 errors)

Authentication and permission errors typically occur due to:

### Missing scopes

Check if your connection has the required scopes using this API:

```bash
curl --location 'https://backend.composio.dev/api/v3/tools/get_scopes_required' \
--header 'x-api-key: YOUR_COMPOSIO_API_KEY' \
--header 'Content-Type: application/json' \
--data '{
    "tools": [
        "SLACK_SENDS_A_MESSAGE_TO_A_SLACK_CHANNEL",
        "SLACK_CREATE_A_REMINDER"    
    ]
}'
```

### Insufficient permissions

Verify the connected account has necessary permissions:

* **Admin requirements**: Some tools require admin-level access
* **Paid accounts**: Certain toolkits need paid subscriptions
  * Example: MS Teams requires Microsoft 365 account + Azure AD tenant

## Tool not working

* Check [tool-specific documentation](/toolkits/introduction) for requirements
* Verify the connected account is active and properly authenticated
* Test with the latest SDK version

## Reporting tool issues

When reporting to support, provide:

* **Error message**: Complete error details
* **Log ID**: From the error response
* **Tool name**: Exact tool slug being executed
* **Connected account ID**: Account used for execution

## Getting help

* **Email**: [support@composio.dev](mailto:support@composio.dev)
* **Discord**: [#support-form](https://discord.com/channels/1170785031560646836/1268871288156323901)


# Triggers

> Debugging and troubleshooting trigger issues

## Unable to create trigger

Check the error message - the account might not have sufficient permissions or required scopes.

## Type errors with trigger payloads

Having issues with trigger payload types? Search [DeepWiki](https://deepwiki.com/ComposioHQ/composio) or use the Ask AI assistant for type definitions and examples.

## Not receiving trigger payloads

Even if the action occurred (email received, Jira issue created, etc.), there may be delays:

* **Gmail triggers**: Uses polling with minimum 1-minute frequency - expect delays of up to a minute
* **Other services**: May have their own polling intervals or webhook delivery delays

## Reporting trigger issues

When reporting to support, provide:

* **Error message**: Complete error details
* **Connected account**: The account ID used for creating the trigger
* **cURL command**: To reproduce the issue
* **Reproduction steps**: Any additional steps needed

## Getting help

* **Email**: [support@composio.dev](mailto:support@composio.dev)
* **Discord**: [#support-form](https://discord.com/channels/1170785031560646836/1268871288156323901)


# Basic FastAPI Server

> Build a simple Gmail agent with Composio and FastAPI

This cookbook will guide you through building agents equipped with tools using `Composio`, `OpenAI`, and `FastAPI`.

## Prerequisites

* Python 3.10+
* [UV](https://docs.astral.sh/uv/getting-started/installation/)
* Composio API key
* OpenAI API key

## Building an AI agent that can interact with `gmail` service

First, let's start with building a simple AI agent with Composio tools that lets the agent interact with `gmail`.

```python
from openai import OpenAI
from composio import Composio
from composio_openai import OpenAIProvider
import os

def run_gmail_agent(
    composio_client: Composio[OpenAIProvider],
    openai_client: OpenAI,
    user_id: str,  # Composio uses the User ID to store and access user-level authentication tokens.
    prompt: str,
):
    """
    Run the Gmail agent using composio and openai clients.
    """
    # Step 1: Fetch the necessary Gmail tools list with Composio
    tools = composio_client.tools.get(
        user_id=user_id,
        tools=[
            "GMAIL_FETCH_EMAILS",
            "GMAIL_SEND_EMAIL",
            "GMAIL_CREATE_EMAIL_DRAFT"
        ]
    )

    # Step 2: Use OpenAI to generate a response based on the prompt and available tools
    response = openai_client.chat.completions.create(
        model="gpt-4.1",
        tools=tools,
        messages=[{"role": "user", "content": prompt}],
    )

    # Step 3: Handle tool calls with Composio and return the result
    result = composio_client.provider.handle_tool_calls(response=response, user_id=user_id)
    return result
```

<Note>
  This example demonstrates a basic agent without state management or agentic loops,
  suitable for simple one-step tasks. For complex multi-step workflows requiring
  memory and iterative reasoning, see our cookbooks with frameworks like LangChain,
  CrewAI, or AutoGen.
</Note>

To invoke this agent, authenticate your users with Composio's managed authentication service.

## Authenticating users

To authenticate your users with Composio you need an authentication config for the given app. In this case you need one for gmail.

To create an authentication config for `gmail` you need `client_id` and `client_secret` from your [Google OAuth Console](https://developers.google.com/identity/protocols/oauth2). Once you have the credentials, use the following piece of code to set up authentication for `gmail`.

```python
from composio import Composio
from composio_openai import OpenAIProvider

def create_auth_config(composio_client: Composio[OpenAIProvider]):
    """
    Create a auth config for the gmail toolkit.
    """
    client_id = os.getenv("GMAIL_CLIENT_ID")
    client_secret = os.getenv("GMAIL_CLIENT_SECRET")
    if not client_id or not client_secret:
        raise ValueError("GMAIL_CLIENT_ID and GMAIL_CLIENT_SECRET must be set")

    return composio_client.auth_configs.create(
        toolkit="GMAIL",
        options={
            "name": "default_gmail_auth_config",
            "type": "use_custom_auth",
            "auth_scheme": "OAUTH2",
            "credentials": {
                "client_id": client_id,
                "client_secret": client_secret,
            },
        },
    )
```

This will create a Gmail authentication config to authenticate your app’s users. Ideally, create one authentication object per project, so check for an existing auth config before creating a new one.

```python
def fetch_auth_config(composio_client: Composio[OpenAIProvider]):
    """
    Fetch the auth config for a given user id.
    """
    auth_configs = composio_client.auth_configs.list()
    for auth_config in auth_configs.items:
        if auth_config.toolkit == "GMAIL":
            return auth_config

    return None
```

<Note>
  Composio platform provides composio managed authentication for some apps to
  fast-track your development, `gmail` being one of them. You can use these
  default auth configs for development, but for production, always use your
  own oauth app configuration.
</Note>

Once you have authentication management in place, we can start with connecting your users to your `gmail` app. Let's implement a function to connect users to your `gmail` app via composio.

```python
from fastapi import FastAPI

# Function to initiate a connected account
def create_connection(composio_client: Composio[OpenAIProvider], user_id: str):
    """
    Create a connection for a given user id and auth config id.
    """
    # Fetch or create the auth config for the gmail toolkit
    auth_config = fetch_auth_config(composio_client=composio_client)
    if not auth_config:
        auth_config = create_auth_config(composio_client=composio_client)

    # Create a connection for the user
    return composio_client.connected_accounts.initiate(
        user_id=user_id,
        auth_config_id=auth_config.id,
    )

# Setup FastAPI
app = FastAPI()

# Connection initiation endpoint
@app.post("/connection/create")
def _create_connection(
    request: CreateConnectionRequest,
    composio_client: ComposioClient,
) -> dict:
    """
    Create a connection for a given user id.
    """
    # For demonstration, using a default user_id. Replace with real user logic in production.
    user_id = "default"

    # Create a new connection for the user
    connection_request = create_connection(composio_client=composio_client, user_id=user_id)
    return {
        "connection_id": connection_request.id,
        "redirect_url": connection_request.redirect_url,
    }
```

Now, you can make a request to this endpoint on your client app, and your user will get a URL which they can use to authenticate.

## Set Up FastAPI service

We will use [`FastApi`](https://fastapi.tiangolo.com/) to build an HTTP service that authenticates your users and lets them interact with your agent. This guide will provide best practices for using composio client in production environments.

### Setup dependencies

FastAPI allows [dependency injection](https://fastapi.tiangolo.com/reference/dependencies/) to simplify the usage of SDK clients that must be singletons. We recommend using composio SDK client as singleton.

```python
import os
import typing_extensions as te

from composio import Composio
from composio_openai import OpenAIProvider

from fastapi import Depends

_composio_client: Composio[OpenAIProvider] | None = None

def provide_composio_client():
    """
    Provide a Composio client.
    """
    global _composio_client
    if _composio_client is None:
        _composio_client = Composio(provider=OpenAIProvider())
    return _composio_client


ComposioClient = te.Annotated[Composio, Depends(provide_composio_client)]
"""
A Composio client dependency.
"""
```

Check [dependencies](./simple_gmail_agent/server/dependencies.py) module for more details.

### Invoke agent via FastAPI

When invoking an agent, make sure you validate the `user_id`.

```python
def check_connected_account_exists(
    composio_client: Composio[OpenAIProvider],
    user_id: str,
):
    """
    Check if a connected account exists for a given user id.
    """
    # Fetch all connected accounts for the user
    connected_accounts = composio_client.connected_accounts.list(
        user_ids=[user_id],
        toolkit_slugs=["GMAIL"],
    )

    # Check if there's an active connected account
    for account in connected_accounts.items:
        if account.status == "ACTIVE":
            return True

        # Ideally you should not have inactive accounts, but if you do, delete them.
        print(f"[warning] inactive account {account.id} found for user id: {user_id}")
    return False

def validate_user_id(user_id: str, composio_client: ComposioClient):
    """
    Validate the user id, if no connected account is found, create a new connection.
    """
    if check_connected_account_exists(composio_client=composio_client, user_id=user_id):
        return user_id

    raise HTTPException(
        status_code=404, detail={"error": "No connected account found for the user id"}
    )

# Endpoint: Run the Gmail agent for a given user id and prompt
@app.post("/agent")
def _run_gmail_agent(
    request: RunGmailAgentRequest,
    composio_client: ComposioClient,
    openai_client: OpenAIClient,  # OpenAI client will be injected as dependency
) -> List[ToolExecutionResponse]:
    """
    Run the Gmail agent for a given user id and prompt.
    """
    # For demonstration, using a default user_id. Replace with real user logic in production.
    user_id = "default"

    # Validate the user id before proceeding
    user_id = validate_user_id(user_id=user_id, composio_client=composio_client)

    # Run the Gmail agent using Composio and OpenAI
    result = run_gmail_agent(
        composio_client=composio_client,
        openai_client=openai_client,
        user_id=user_id,
        prompt=request.prompt,
    )
    return result
```

<Note>
  Check [server](./simple_gmail_agent/server/) module for service implementation
</Note>

## Putting everything together

So far, we have created an agent with ability to interact with `gmail` using the `composio` SDK, functions to manage connected accounts for users and a FastAPI service. Now let's run the service.

<Note>
  Before proceeding, check the [code](./simple_gmail_agent/server/api.py) for utility endpoints not discussed in the cookbook
</Note>

1. Clone the repository
   ```bash
   git clone git@github.com:composiohq/composio-fastapi
   cd composio-fastapi/
   ```
2. Setup environment

   ```bash
   cp .env.example .env
   ```

   Fill the api keys

   ```dotenv
   COMPOSIO_API_KEY=
   OPENAI_API_KEY=
   ```

   Create the virtual env

   ```bash
   make env
   source .venv/bin/activate
   ```
3. Run the HTTP server
   ```bash
   uvicorn simple_gmail_agent.server.api:create_app --factory
   ```

## Testing the API with curl

Assuming the server is running locally on `http://localhost:8000`.

### Check if a connection exists

```bash
curl -X POST http://localhost:8000/connection/exists
```

### Create a connection

Note: The body fields are required by the API schema, but are ignored internally in this example service.

```bash
curl -X POST http://localhost:8000/connection/create \
  -H "Content-Type: application/json" \
  -d '{
    "user_id": "default",
    "auth_config_id": "AUTH_CONFIG_ID_FOR_GMAIL_FROM_THE_COMPOSIO_DASHBOARD"
  }'
```

Response includes `connection_id` and `redirect_url`. Complete the OAuth flow at the `redirect_url`.

### Check connection status

Use the `connection_id` returned from the create step.

```bash
curl -X POST http://localhost:8000/connection/status \
  -H "Content-Type: application/json" \
  -d '{
    "user_id": "default",
    "connection_id": "CONNECTION_ID_FROM_CREATE_RESPONSE"
  }'
```

### Run the Gmail agent

Requires an active connected account for the `default` user.

```bash
curl -X POST http://localhost:8000/agent \
  -H "Content-Type: application/json" \
  -d '{
    "user_id": "default",
    "prompt": "Summarize my latest unread emails from the last 24 hours."
  }'
```

### Fetch emails (direct action)

```bash
curl -X POST http://localhost:8000/actions/fetch_emails \
  -H "Content-Type: application/json" \
  -d '{
    "user_id": "default",
    "limit": 5
  }'
```

These examples are intended solely for testing purposes.

## Using Composio for managed auth and tools

Composio reduces boilerplate for building AI agents that access and use various apps. In this cookbook, to build Gmail integration without Composio, you would have to write code to

* manage Gmail OAuth app
* manage user connections
* tools for your agents to interact with Gmail

Using Composio simplifies all of the above to a few lines of code as shown in the cookbook.

## Best practices

**🎯 Effective Prompts**:

* Be specific: "Send email to [john@company.com](mailto:john@company.com) about tomorrow's 2pm meeting" works better than "send email"
* Include context: "Reply to Sarah's email about the budget with our approval"
* Use natural language: The agent understands conversational requests

**🔒 User Management**:

* Use unique, consistent `user_id` values for each person
* Each user maintains their own Gmail connection
* User IDs can be email addresses, usernames, or any unique identifier

## Troubleshooting

**Connection Issues**:

* Ensure your `.env` file has valid `COMPOSIO_API_KEY` and `OPENAI_API_KEY`
* Check if the user has completed Gmail authorization.
* Verify the user\_id matches exactly between requests

**API Errors**:

* Check the server logs for detailed error messages
* Ensure request payloads match the expected format
* Visit `/docs` endpoint for API schema validation

**Gmail API Limits**:

* Gmail has rate limits; the agent will handle these gracefully
* For high-volume usage, consider implementing request queuing

